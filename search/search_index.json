{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"In\u00edcio","text":""},{"location":"#sumario","title":"Sum\u00e1rio","text":""},{"location":"#capitulo-1-hash-table","title":"Cap\u00edtulo 1 - Hash Table","text":"<ul> <li>1.1 Colis\u00f5es<ul> <li>1.1.1 Endere\u00e7amento aberto</li> <li>1.1.2 Double Hash</li> <li>1.1.3 Encadeamento Separado</li> </ul> </li> <li>1.2 B\u00f4nus - Discuss\u00e3o sobre complexidades</li> </ul>"},{"location":"#capitulo-2-arvore-red-black","title":"Cap\u00edtulo 2 - \u00c1rvore Red Black","text":"<ul> <li>2.1 Structs</li> <li>2.2 Regras da Red Black<ul> <li>2.2.1 Algoritmos de Balanceamento</li> <li>2.2.2 Inser\u00e7\u00f5es em \u00c1rvore Red Black</li> <li>2.2.3 Algoritmos de inser\u00e7\u00e3o</li> </ul> </li> <li>2.3 Alturas de uma Red Black<ul> <li>2.3.1 Altura total</li> <li>2.3.2 Altura Negra</li> </ul> </li> <li>2.4 B\u00f4nus - \u00c1rvore 2-3</li> </ul>"},{"location":"#capitulo-3-fila-de-prioridades","title":"Cap\u00edtulo 3 - Fila de Prioridades","text":"<ul> <li>3.1 Conceitos<ul> <li>3.1.1 Fila de Prioridades crescente e decrescente (Min heap e Max Heap)</li> <li>3.1.2 Item m\u00ednimo e item m\u00e1ximo</li> <li>3.1.3 Complexidades</li> </ul> </li> <li>3.2 Algoritmos<ul> <li>3.2.1 Structs e macros</li> <li>3.2.2 Conserta para cima (swim)</li> <li>3.2.3 Conserta para baixo (sink)</li> <li>3.2.4 Inser\u00e7\u00e3o, remo\u00e7\u00e3o e consulta</li> </ul> </li> </ul>"},{"location":"#capitulo-4-grafos","title":"Cap\u00edtulo 4 - Grafos","text":"<ul> <li>4.1 Implementa\u00e7\u00e3o<ul> <li>4.1.1 Matriz de Adjac\u00eancia</li> <li>4.1.2 Lista de Adjac\u00eancia</li> <li>4.1.3 B\u00f4nus - Matriz x Lista</li> </ul> </li> <li>4.2 Grafo completo</li> <li>4.3 Grafos dirigidos ou digrafos</li> <li>4.4 Conceitos<ul> <li>4.4.1 Classifica\u00e7\u00e3o de v\u00e9rtices</li> <li>4.4.2 Caminho</li> <li>4.4.3 Conectividade</li> <li>4.4.4 Grafos dirigidos conexos ac\u00edclicos</li> <li>4.4.5 Grafo dirigido fortemente conexo</li> <li>4.4.6 Fecho Transitivo</li> <li>4.4.7 Grafos ponderados(peso nas arestas)</li> </ul> </li> <li>4.5 Structs e algoritmos iniciais</li> <li>4.6 Busca em Largura (BFS)</li> <li>4.7 Busca em Profundidade (DFS)</li> <li>4.8 Problemas Cl\u00e1ssicos e Algoritmos Fundamentais<ul> <li>4.8.1 Problema do Menor caminho<ul> <li>4.8.1.1 Dijkstra</li> <li>4.8.1.2 BellmanFord</li> </ul> </li> <li>4.8.2 Problema das \u00e1rvores geradoras e \u00e1rvores geradoras de custo m\u00ednimo (MST)<ul> <li>4.8.2.1 Prim</li> <li>4.8.2.2 Kruskal</li> </ul> </li> </ul> </li> </ul>"},{"location":"#capitulo-5-quickselect","title":"Cap\u00edtulo 5 - Quickselect","text":""},{"location":"#listas-de-exercicios","title":"Listas de Exerc\u00edcios","text":"<p>Esta se\u00e7\u00e3o cont\u00e9m as listas de exerc\u00edcios desenvolvidos na disciplina.</p>"},{"location":"#lista-i-desenferrujando-para-semestre","title":"Lista I - Desenferrujando para semestre","text":"<p>A primeira lista \u00e9 voltada para revis\u00e3o e familiariza\u00e7\u00e3o com o formato das listas.</p> <ul> <li>A : Ol\u00e1 Mundo</li> <li>B : Soma2</li> <li>C : SomaN</li> <li>D : EOF</li> <li>E : Viagem Aconselha</li> <li>F : Desfazer No Editor/cntrl z</li> <li>G : Cofrinhos da v\u00f3 Vit\u00f3ria</li> <li>H : Ultrapassa Minimamente</li> <li>I : Soma String</li> <li>J : Quem vai ser Reprovado</li> <li>K : Frequ\u00eancia na aula</li> <li>L : Analisando dados de degusta\u00e7\u00e3o</li> <li>M : N\u00famero Proibido</li> <li>N : Notas da Turma</li> <li>O : Mescla Listas</li> </ul>"},{"location":"#lista-ii-hashing","title":"Lista II - hashing","text":"<p>A segunda lista tinha o objetivo de resolver exerc\u00edcios relacionados \u00e0 Hash Table.</p> <ul> <li>A : Desfile dos Patos</li> <li>B : Diga-me a frequ\u00eancia</li> <li>C : Elei\u00e7\u00e3o U.R.S.A.L</li> <li>D : Notas Curiosas</li> <li>E : Notas</li> <li>F : HashIT!</li> <li>G : Hash</li> <li>H : Mensagens Nlogoniences</li> </ul>"},{"location":"#listas-iii-priority-queue","title":"Listas III - Priority Queue","text":"<p>A terceira lista cont\u00e9m exerc\u00edcios de Heap.</p> <ul> <li>A : Menores Placas</li> <li>B : Churrascarias da Avenida</li> <li>C : Minimun Stocks</li> </ul>"},{"location":"#lista-iv-quickselect","title":"Lista IV - QuickSelect","text":"<p>A quarta lista tem como enfoque o algoritmo Quickselect, um algoritmo de busca baseado no algoritmo de ordena\u00e7\u00e3o QuickSort.</p> <ul> <li>A : Classificados de Sementes</li> <li>B : kk-p\u00e1gina</li> <li>C : Desfile dos Patos - QuickSelect</li> <li>D : Menores Placas - QuickSelect</li> </ul>"},{"location":"#lista-v-grafos-o-inicio","title":"Lista V - Grafos, o in\u00edcio","text":"<p>A quinta lista introduz os conceitos e algoritmos b\u00e1sicos de Grafos.</p> <ul> <li>A : Eu vou estar l\u00e1!</li> <li>B : Estradas asfaltadas</li> <li>C : Estradas asfaltadas - viagem a\u00e9rea</li> <li>D : Natureza</li> <li>E : Ir e vir</li> </ul>"},{"location":"#lista-vi-busca-em-grafos","title":"Lista VI - Busca em Grafos","text":"<p>A sexta lista coloca em pr\u00e1tica alguns dos algoritmos fundamentais de Grafos, como o Algoritmo de Dijkstra e o Algoritmo de BellmanFord.</p> <ul> <li>A: Estradas asfaltadas - perguntando conex\u00f5es</li> <li>B: Cai fora LAG</li> <li>C: Caminho das Pontes</li> <li>D: O ch\u00e3o virou lava</li> <li>E: Regra dos seis apertos de m\u00e3o</li> </ul>"},{"location":"apostila/FiladePrioridades/","title":"3. Fila de Prioridades","text":"<p>A Fila de Prioridades ou Heap, \u00e9 uma estrutura que organiza os elementos com base em um valor que \u00e9 definido como prioridade. Dispondo os elementos tal que, o de maior prioridade sempre estar\u00e1 no topo da fila, admite chaves reptidas, ou seja, com a mesma prioridade. Ela \u00e9 representada como uma \u00e1rvore bin\u00e1ria em vetor, no qual o \u00edndice zero fica inutilizado, e os filhos de um elemento k, s\u00e3o, respectivamente, 2k e 2k + 1, Reciprocamente o pai de qualquer elemento k \u00e9 k/2.</p> <ul> <li>Exemplo:</li> </ul> <p>Legenda: Roxo: Pai (k), Vermelho: filho (2k), Azul: filho (2k + 1).</p> <pre><code>    graph LR;\n    A[0] --&gt; B[1]\n    B --&gt; C[2]\n    C --&gt; D[3]\n    D --&gt; E[4]\n    E --&gt; F[5]\n    F --&gt; G[6]\n    G --&gt; H[7]\n\n    style B stroke-width:3px, stroke: #9F00FF\n    style C stroke-width:3px, stroke: #FF0000 \n    style D stroke-width:3px, stroke: #0000FF\n\n\n    classDef myNodeStyle fill:#fff;</code></pre> <pre><code>    graph LR;\n    A[0] --&gt; B[1]\n    B --&gt; C[2]\n    C --&gt; D[3]\n    D --&gt; E[4]\n    E --&gt; F[5]\n    F --&gt; G[6]\n    G --&gt; H[7]\n\n\n    style C stroke-width:3px, stroke: #9F00FF\n    style E stroke-width:3px, stroke: #FF0000 \n    style F stroke-width:3px, stroke: #0000FF\n\n\n    classDef myNodeStyle fill:#fff;</code></pre> <pre><code>    graph LR;\n    A[0] --&gt; B[1]\n    B --&gt; C[2]\n    C --&gt; D[3]\n    D --&gt; E[4]\n    E --&gt; F[5]\n    F --&gt; G[6]\n    G --&gt; H[7]\n\n\n    style D stroke-width:3px, stroke: #9F00FF\n    style G stroke-width:3px, stroke: #FF0000 \n    style H stroke-width:3px, stroke: #0000FF\n\n\n    classDef myNodeStyle fill:#fff;</code></pre> <p>E assim sucessivamente.</p>"},{"location":"apostila/FiladePrioridades/#31-conceitos","title":"3.1 Conceitos","text":""},{"location":"apostila/FiladePrioridades/#311-fila-de-prioridades-crescente-e-decrescente-min-heap-e-max-heap","title":"3.1.1 Fila de prioridades crescente e decrescente (Min Heap e Max Heap)","text":"<p>Na heap crescente o elemento de menor prioridade est\u00e1 no topo da fila, conforme se move para baixo a prioridade dos elementos aumentam. Na heap decrescente o elemento de maior prioridade est\u00e1 no topo da fila, conforme se move para baixo a prioridade dos elementos diminuem.</p>"},{"location":"apostila/FiladePrioridades/#312-item-maximo-e-item-minimo","title":"3.1.2 Item m\u00e1ximo e item m\u00ednimo","text":"<p>Um item K \u00e9 m\u00e1ximo se nenhum item \u00e9 estritamente maior que K. Um item K \u00e9 m\u00ednimo se nenhum item \u00e9 estritamente menor que K. Podem existir mais de um item m\u00e1ximo e mais de um item m\u00ednimo.</p>"},{"location":"apostila/FiladePrioridades/#313-complexidades","title":"3.1.3 Complexidades","text":"Inser\u00e7\u00e3o Remo\u00e7\u00e3o Consulta Priority Queue O(log n) O(log n) O(1)"},{"location":"apostila/FiladePrioridades/#32-algoritmos","title":"3.2 Algoritmos","text":""},{"location":"apostila/FiladePrioridades/#321-struct-e-macros","title":"3.2.1 Struct e macros","text":"<pre><code>    #define less(a,b) (a &lt; b)\n    #define greater(a,b) (a &gt; b)\n    #define swap(a,b)   \\\n        {               \\\n            Item temp = a; \\\n            a = b;      \\\n            b = temp;   \\\n        }\n\n    typedef struct Heap\n    {\n        Item *data;\n        int size;\n    }Heap;\n</code></pre> <p>Obs: \"Item\" pode ser de qualquer tipo: int, char, tipos abstratos, etc... </p>"},{"location":"apostila/FiladePrioridades/#322-conserta-para-cima-swim","title":"3.2.2 Conserta para cima (swim)","text":"<p>Suponha que em algum momento estejamos com a seguinte Heap crescente \"estragada\":</p> <p>Obs: quanto mais pr\u00f3ximo do fim do alfabeto, maior a prioridade</p> <pre><code>    graph LR;\n    S --&gt; P --&gt; R --&gt; G1(G) --&gt; T --&gt; O --&gt; A --&gt; E --&gt; I --&gt; H --&gt; G2(G)\n\n    style T stroke-width: 3px, stroke: #FF0000</code></pre> <ul> <li>Observe que \" T \" est\u00e1 em uma posi\u00e7\u00e3o errada, j\u00e1 que \u00e9 o elemento de maior prioridade, ent\u00e3o temos que consertar sua posi\u00e7\u00e3o.</li> </ul> <pre><code>    graph LR;\n    S --&gt; T --&gt; R --&gt; G1(G) --&gt; P --&gt; O --&gt; A --&gt; E --&gt; I --&gt; H --&gt; G2(G)\n\n    style T stroke-width: 3px, stroke: #FF0000\n    style P stroke-width: 3px, stroke: #AF0F33</code></pre> <ul> <li>O \" T \" assume a posi\u00e7\u00e3o de \" P \".</li> </ul> <pre><code>    graph LR;\n    T --&gt; S --&gt; R --&gt; G1(G) --&gt; P --&gt; O --&gt; A --&gt; E --&gt; I --&gt; H --&gt; G2(G)\n\n    style T stroke-width: 3px, stroke: #FF0000\n    style S stroke-width: 3px, stroke: #AF0F33</code></pre> <ul> <li>E, por fim, o \" T \" assume sua posi\u00e7\u00e3o correta. O algoritmo que foi aplicado para resolver a incongru\u00eancia, pode ser chamado de \"Conserta para cima\" ou \"swim\".</li> </ul> <p>Fun\u00e7\u00e3o \"Conserta para cima\" ou fixup:</p> <pre><code>    void fixup(Item *hp, int k)\n    {\n        //less() ou greater() depende da implementa\u00e7\u00e3o\n        for(int i = k; i &gt; 1 &amp;&amp; less(hp[i/2], hp[i]); i/=2) \n            swap(hp[i], hp[i/2]);\n    }\n\n    void fixup2(Item *hp, int k)\n    {\n        //less() ou greater() depende da implementa\u00e7\u00e3o\n        while(k &gt; 1 &amp;&amp; less(v[k/2], v[k]))\n        {\n            swap(v[k], v[k/2]);\n            k /= 2;\n        }\n    }\n</code></pre>"},{"location":"apostila/FiladePrioridades/#323-conserta-para-baixo-sink","title":"3.2.3 Conserta para baixo (sink)","text":"<p>Suponha que em algum momento estejamos com a seguinte Heap decrescente \"estragada\":</p> <p>Obs: quanto mais pr\u00f3ximo do fim do alfabeto, maior a prioridade</p> <pre><code>    graph LR;\n    T --&gt; H --&gt; R --&gt; P --&gt; S --&gt; O --&gt; A --&gt; E --&gt; I --&gt; N --&gt; G\n\n    style H stroke-width: 3px, stroke: #FF0000\n</code></pre> <ul> <li>Observe que \" H \" est\u00e1 em uma posi\u00e7\u00e3o errada, est\u00e1 em uma posi\u00e7\u00e3o acima de \" P \" e \" S \", mesmo tendo menor prioridade.</li> </ul> <pre><code>    graph LR;\n    T --&gt; S --&gt; R --&gt; P --&gt; H --&gt; O --&gt; A --&gt; E --&gt; I --&gt; N --&gt; G\n\n    style H stroke-width: 3px, stroke: #FF0000\n    style S stroke-width: 3px, stroke: #AF0F33</code></pre> <ul> <li>\" H \" troca com \" S \" (\"S\" j\u00e1 est\u00e1 na posi\u00e7\u00e3o correta pois tem maior prioridade que qualquer elemento abaixo dele).</li> </ul> <pre><code>    graph LR;\n    T --&gt; S --&gt; R --&gt; P --&gt; N --&gt; O --&gt; A --&gt; E --&gt; I --&gt; H --&gt; G\n\n    style H stroke-width: 3px, stroke: #FF0000\n    style N stroke-width: 3px, stroke: #AF0F33</code></pre> <ul> <li>\" H \" troca com \" N \" (\"N\" j\u00e1 est\u00e1 na posi\u00e7\u00e3o correta pois tem maior prioridade que qualquer elemento abaixo dele).</li> </ul> <p>Fun\u00e7\u00e3o \"Conserta para baixo\" ou fixdown: <pre><code>    void fixdown(Item *hp, int k, int size)\n    {\n        int j;\n        while(2*k &lt;= size)\n        {\n            j = 2*k;                            //j = filho 2k\n            if(j &lt; size &amp;&amp; less(v[j + 1], v[j]))  //verfica qual filho \u00e9 menor\n                j++;                            //muda para filho (2k + 1), se for menor\n            if(!less(v[k], v[j]))               //se o filho(j) tem menor prioridade que o pai(k), quebra o la\u00e7o\n                break;\n            swap(v[k], v[j]);                   // troca pai e filho\n            k = j;                              //pai assume posi\u00e7\u00e3o do filho\n        }\n    }\n</code></pre></p>"},{"location":"apostila/FiladePrioridades/#324-insercao-remocao-e-consulta","title":"3.2.4 Inser\u00e7\u00e3o, remo\u00e7\u00e3o e consulta","text":"<pre><code>    Heap PQinit(int n)\n    {\n        Heap hp;\n        hp.size = 0;\n        hp.data = malloc(sizeof(Item) * (k + 1));\n\n        return hp;\n    }\n\n    void PQinsert(Heap *hp, Item c)\n    {\n        hp-&gt;data[++hp-&gt;size] = c;\n        fixup(hp-&gt;heap, hp-&gt;size);\n    }\n\n    Item PQespia(Heap hp)\n    {\n        return hp.data[1];\n    }\n\n    Item PQremove(Heap *hp, int i)\n    {\n        Item t = hp-&gt;data[i];\n        hp-&gt;data[i] = hp-&gt;data[hp-&gt;size--];\n        fixdown(hp-&gt;data, hp-&gt;size, i);\n\n        return t;\n    }\n\n    void PQchange(Heap *hp, int k, int newPriority)\n    {\n        if(k &gt; 0 &amp;&amp; k &lt; hp-&gt;size){\n            hp-&gt;array[k].priority = newPriority\n            fixup(hp, k);\n            fixdown(hp, k, PQ-&gt;size);\n        }\n    }\n</code></pre>"},{"location":"apostila/Grafos/","title":"4. Grafos","text":"<p>Grafos s\u00e3o estruturas de dados amplamente utilizadas na computa\u00e7\u00e3o. S\u00e3o uma \u00f3tima maneira de representar relacionamentos entre elementos, como por exemplo: mapas, redes, encana\u00e7\u00e3o, aeroportos, etc. Podem ser representados graficamente como um conjunto de v\u00e9rtices e arestas.</p>"},{"location":"apostila/Grafos/#41-implementacao","title":"4.1 Implementa\u00e7\u00e3o","text":"<p>Existem duas principais formas de reprensent\u00e1-los. Matriz de adjac\u00eancia ou Lista de adjac\u00eancia.</p>"},{"location":"apostila/Grafos/#411-matriz-de-adjacencia","title":"4.1.1 Matriz de Adjac\u00eancia","text":"<p>Uma matriz bidimensional que representa a rela\u00e7\u00e3o entre os v\u00e9rtices. Os elementos da matriz indicam se h\u00e1 ou n\u00e3o uma rela\u00e7\u00e3o entre os v\u00e9rtices. \u00datil para grafos densos (completos ou quase completos). Consome espa\u00e7o proporcional \u00e0 V\u00b2 (onde V \u00e9 o n\u00famero de v\u00e9rtices). Acesso r\u00e1pido para verificar a exist\u00eancia de arestas (O(1)).</p> <ul> <li>Imagine o seguinte grafo:</li> </ul> <pre><code>    graph LR;\n    0 --- 1 &amp; 2\n    1 --- 2\n    2 --- 3\n    4\n\n    classDef myNodeStyle stroke-width: 1px, rx: 10px, ry: 10px;\n    class 0,1,2,3,4 myNodeStyle;</code></pre> <ul> <li>Sua respectiva matriz de adjac\u00eancia poderia ser representada da seguinte maneira:</li> </ul> 0 1 2 3 4 0 1 1 1 0 0 1 1 1 1 0 0 2 1 1 1 1 0 3 0 0 1 1 0 4 0 0 0 0 1 <ul> <li>Os ' 1 's representam as conex\u00f5es e os ' 0 's a aus\u00eancia delas, por padr\u00e3o a diagonal principal j\u00e1 \u00e9 preenchida com ' 1 ', a conex\u00e3o de um elemento com ele mesmo \u00e9 trivial.</li> </ul> <p>Veja a Implementa\u00e7\u00e3o.</p>"},{"location":"apostila/Grafos/#412-lista-de-adjacencia","title":"4.1.2 Lista de Adjac\u00eancia","text":"<p>A ideia da lista de adjac\u00eancia \u00e9 construir um vetor de tamanho V (n\u00famero de v\u00e9rtices) onde cada \u00edndice representa um v\u00e9rtice do grafo, e cada espa\u00e7o do vetor cont\u00e9m um ponteiro para uma lista encadeada, que representa as conex\u00f5es daquele v\u00e9rtice com outros v\u00e9rtices do grafo. Pode ser comparada ao Encadeamento Separado da Hash Table.</p> 0 1 2 3 4 1 2 3 2 <p>Note que \u00e9 uma representa\u00e7\u00e3o bem mais enxuta comparada \u00e0 matriz, logo tamb\u00e9m ocupa menos espa\u00e7o. Vale ressaltar que, uma conex\u00e3o n\u00e3o precisa ser representada duas vezes, ou seja, se um v\u00e9rtice tem conex\u00e3o com um v\u00e9rtice menor que ele mesmo, n\u00e3o \u00e9 necess\u00e1rio incluir esta aresta na lista de adjac\u00eancias, pois esta aresta j\u00e1 estar\u00e1 representada no v\u00e9rtice menor, por exemplo a aresta (0, 2), note que o 0 j\u00e1 cont\u00e9m a conex\u00e3o com o 2, portanto n\u00e3o se faz necess\u00e1rio representar esta conex\u00e3o novamente no v\u00e9rtice 2. Obviamente isto s\u00f3 \u00e9 verdadeiro para grafos n\u00e3o direcionados, neste caso, a\u00ed sim, eu teria que inserir esta conex\u00e3o em ambos v\u00e9rtices.</p> <p>Veja a Implementa\u00e7\u00e3o.</p>"},{"location":"apostila/Grafos/#413-bonus-matriz-x-lista","title":"4.1.3 B\u00f4nus - Matriz X Lista","text":"<p>Apresentadas ambas estrat\u00e9gias, podemos definir algumas vantagens e desvantagens entre elas: %3E E = n\u00famero de arestas , V = n\u00famero de v\u00e9rtices</p> Vetor de Arestas Matriz de Adjac\u00eancia Lista de Adjac\u00eancia space E V\u00b2 V + E initialize 1 V\u00b2 V copy E V\u00b2 E destroy 1 V E insert Edge 1 1 1 find/remove Edge E 1 V Vertex is isolate? E V 1 Path from U to V E * log V V\u00b2 E + V"},{"location":"apostila/Grafos/#42-grafo-completo","title":"4.2 Grafo Completo","text":"<p>Todos os v\u00e9rtices s\u00e3o ligados entre si, ou seja, todo v\u00e9rtice tem uma aresta para cada outro v\u00e9rtice no grafo. Totalizando o de m\u00e1ximo v*(v-1)/2 arestas, onde 'v' \u00e9 o n\u00famero de v\u00e9rtices.</p> <pre><code>    graph LR;\n    0 --- 1 &amp; 2 &amp; 3\n    2 --- 3\n    1 --- 2 &amp; 3\n\n\n    classDef myNodeStyle stroke-width: 1px, rx: 10px, ry: 10px;\n    class 0,1,2,3,4 myNodeStyle;</code></pre> <ul> <li>Note que todos os v\u00e9rtices tem liga\u00e7\u00e3o entre si, tornando o grafo acima completo. Com um total de 4 v\u00e9rtices, t\u00eam-se um total de 4*3/2 arestas, ou 6 arestas.</li> </ul>"},{"location":"apostila/Grafos/#43-grafos-dirigidos-ou-digrafos","title":"4.3 Grafos dirigidos ou Digrafos","text":"<p>S\u00e3o grafos nos quais as arestas possuem dire\u00e7\u00e3o, ou seja, se tenho uma aresta de '0' para '1', n\u00e3o necessariamente tenho uma aresta de '1' para '0'.</p> <pre><code>    graph LR;\n    4 --&gt; 0 &amp; 1\n    0 --&gt; 1\n    1 --&gt; 2\n    2 --&gt; 0 &amp; 3\n    0 --&gt; 3\n\n\n    classDef myNodeStyle stroke-width: 1px, rx: 10px, ry: 10px;\n    class 0,1,2,3,4 myNodeStyle;</code></pre> <ul> <li>H\u00e1 um fluxo entre os v\u00e9rtices, a partir do \"0\" consigo alcan\u00e7ar qualquer v\u00e9rtice, por\u00e9m a partir do \"3\" n\u00e3o consigo atingir nenhum outro v\u00e9rtice.</li> </ul>"},{"location":"apostila/Grafos/#44-conceitos","title":"4.4 Conceitos","text":""},{"location":"apostila/Grafos/#441-classificacao-de-vertices","title":"4.4.1 Classifica\u00e7\u00e3o de V\u00e9rtices","text":"<ul> <li>V\u00e9rtices \"sink\" s\u00e3o aquelas que n\u00e3o possuem arestas saindo dele, apenas chegando, 3 \u00e9 um v\u00e9rtice sink.</li> <li>V\u00e9rtices \"source\" s\u00e3o aqueles que n\u00e3o possuem arestas chegando n'ele, apenas saindo, 4 \u00e9 um v\u00e9rtice source.</li> </ul>"},{"location":"apostila/Grafos/#442-caminho","title":"4.4.2 Caminho","text":"<p>Caminho em grafos \u00e9 a sequ\u00eancia de v\u00e9rtices em que cada v\u00e9rtice sucessivo \u00e9 adjacente ao predecessor, ou seja, cada v\u00e9rtice est\u00e1 conectado ao seguinte por uma aresta. S\u00e3o uma parte essencial da an\u00e1lise e resolu\u00e7\u00e3o de problemas com grafos e podem ter diversas aplica\u00e7\u00f5es, incluindo navega\u00e7\u00e3o, otimiza\u00e7\u00e3o, planejamento de rotas, etc.</p> <ul> <li> <p>Caminho Simples - Um caminho onde todos os v\u00e9rtices s\u00e3o distintos, exceto o primeiro e \u00faltimo, que podem ser iguais. Obs: N\u00e3o necessariamente o caminho mais curto.</p> </li> <li> <p>Caminho fechado (Circuito) - Um caminho no qual o v\u00e9rtice de partida e v\u00e9rtice de chegada \u00e9 o mesmo. Se for um caminho simples, todos os v\u00e9rtices no caminho s\u00e3o distintos, \u00e9 chamado de Ciclo.</p> </li> </ul> <p>Exemplo:</p> <pre><code>    graph LR;\n    0 --- 1\n    1 --- 2\n    2 --- 0\n\n    classDef myNodeStyle stroke-width: 1px, rx: 10px, ry: 10px;\n    class 0,1,2,3,4 myNodeStyle;</code></pre> <ul> <li>Caminho m\u00ednimo -   O caminho m\u00ednimo entre dois v\u00e9rtices \u00e9 o caminho mais curto em termos de custo, peso ou dist\u00e2ncia. Isso \u00e9 frequentemente usado em problemas de otimiza\u00e7\u00e3o, como encontrar a rota mais curta em um sistema de transporte.</li> </ul>"},{"location":"apostila/Grafos/#443-conectividade","title":"4.4.3 Conectividade","text":"<ul> <li>Grafo Conexo - Um grafo \u00e9 conexo se h\u00e1 um caminho de cada v\u00e9rtice para todo outro v\u00e9rtice. Em outras palavras n\u00e3o importa o v\u00e9rtice de partida voc\u00ea sempre ser\u00e1 capaz de alcan\u00e7ar qualquer outro v\u00e9rtice do grafo. </li> </ul> <p>Exemplo:</p> <pre><code>    graph LR;\n    0 --- 1\n    1 --- 2\n    2 --- 0\n\n    classDef myNodeStyle stroke-width: 1px, rx: 10px, ry: 10px;\n    class 0,1,2,3,4 myNodeStyle;</code></pre> <ul> <li>Grafo n\u00e3o Conexo - Um grafo que n\u00e3o \u00e9 conexo consiste em um conjunto de outros componentes conexos.</li> </ul> <p>Exemplo:</p> <pre><code>    graph LR;\n    0 --- 1\n    1 --- 2\n    2 --- 0\n    4 --- 5\n\n    classDef myNodeStyle stroke-width: 1px, rx: 10px, ry: 10px;\n    class 0,1,2,3,4,5 myNodeStyle;</code></pre>"},{"location":"apostila/Grafos/#444-grafos-dirigidos-conexos-aciclicos","title":"4.4.4 Grafos dirigidos conexos ac\u00edclicos","text":"<ul> <li>\u00c9 um grafo dirigido que n\u00e3o possui ciclos. \u00c1rvores s\u00e3o grafos dirigidos ac\u00edclicos, observe que Toda \u00e1rvore \u00e9 um digrafo ac\u00edclico, por\u00e9m nem todo digrafo ac\u00edclico \u00e9 uma \u00e1rvore, v\u00e9rtices de um digrafo podem ter mais de uma aresta e n\u00e3o necessariamente existe uma hierarquia entre os filhos e o pai, diferentemente de uma \u00e1rvore.</li> </ul> <pre><code>\n    graph TD;\n    0 --&gt; 1 &amp; 2;\n    1 --&gt; 5 &amp; 3 &amp; 4;\n    2 --&gt; 6 &amp; 7;\n    3 --&gt; 8 &amp; 9 &amp; 10;\n    4 --&gt; 11;\n    7 --&gt; 12 &amp; 13;\n\n    classDef myNodeStyle stroke-width: 1px, rx: 10px, ry: 10px;\n    class 0,1,2,3,4,5,6,7,8,9,10,11,12,13 myNodeStyle;</code></pre>"},{"location":"apostila/Grafos/#445-grafo-dirigido-fortemente-conexo","title":"4.4.5 Grafo dirigido fortemente conexo","text":"<p>A no\u00e7\u00e3o de conectividade forte \u00e9 aplicada aos digrafos. Um grafo direcionado ou dirigido \u00e9 considerado fortemente conexo se para cada par de v\u00e9rtices (v, w) existe uma aresta de v para w e uma aresta de w para v.</p>"},{"location":"apostila/Grafos/#446-fecho-transitivo","title":"4.4.6 Fecho Transitivo","text":"<p>O Fecho Transitivo de um grafo dirigido \u00e9 um grafo dirigido com o mesmo conjunto de v\u00e9rtices mas com uma aresta de s para t, se e somente se, existe um caminho dirigido de s \u00e0 t no grafo dirigido.</p> <p>Floyd Warshall:</p> Floyd Warshall<pre><code>    void graphtc(Graph *g){\n        int i, s, t;\n        //Inicia uma matriz de adj\n        g-&gt;tc = MATRIXinit(g-&gt;v, g-&gt;v, 0);\n        for(s = 0; s %3C g-&gt;v; s\n            for(t = 0; t &lt; g-&gt;v; t++)\n                g-&gt;tc[s][t] = g-&gt;adj[s][t];\n\n        //seta a diagonal principal\n        for(s = 0; s &lt; g-&gt;v; s++)\n            g-&gt;tc[s][s] = 1;\n\n        //Percorre as linhas i e as colunas s\n        for(i = 0; i &lt; g-&gt;v; i++)\n            for(s = 0; s &lt; g-&gt;v; s++)\n                //Verifica se existe um caminho de s para i\n                if(g-&gt;tc[s][i] == i)\n                    //Percorre todos os elementos da linha i\n                    for(t = 0; t &lt; g-&gt;v; t++)\n                        //Verifica se h\u00e1 caminho entre i e t\n                        if(g-&gt;tc[i][t] == 1)\n                            //Se sim ent\u00e3o tamb\u00e9m existe caminho de s para t\n                            //Cria uma nova aresta\n                            g-&gt;tc[s][t] = 1;\n    }\n</code></pre>"},{"location":"apostila/Grafos/#447-grafos-ponderados-peso-nas-arestas","title":"4.4.7 Grafos Ponderados (Peso nas arestas)","text":"<p>O peso nas arestas pode ser, por exemplo, a dist\u00e2ncia f\u00edsica entre dois pontos.</p> <pre><code>    graph LR;\n    a[Plano Piloto] --&gt;|40 km| b[Taguatinga] --&gt;|20 km| c[N\u00facleo Bandeirante]\n    a --&gt;|30 km| c\n    c --&gt;|20 km| a</code></pre> <p>Como implementar peso nas arestas?</p> <ul> <li>Matriz de adjac\u00eancias:</li> </ul> 1 2 3 1 0 40 30 2 \u221e 0 20 3 20 \u221e 0"},{"location":"apostila/Grafos/#45-structs-e-algoritmos-iniciais","title":"4.5 Structs e algoritmos iniciais","text":"<p>A estrutura b\u00e1sica para representar um grafo \u00e9 a Aresta(Edge), que simboliza a conex\u00e3o entre dois V\u00e9rtices(Vertex), que podem ser abstra\u00eddos para um Item em quest\u00e3o, que pode ser um <code>int</code>, <code>char</code> ou qualquer <code>tipo abstrato</code> que for definido.</p> <pre><code>    typedef struct Edge{\n        int v; \n        int w;\n    }Edge;  \n</code></pre> <p>Outras estruturas fundamentais s\u00e3o as de Matriz de Adjac\u00eancia e Lista de Adjac\u00eancia, que s\u00e3o:</p> <pre><code>    #define MAX_VERTEX 100 \n\n    //Matriz de Adjac\u00eancia\n    typedef struct Graph{\n        int numVertex;                      //Guarda o n\u00famero total de v\u00e9rtices\n        int size;                           //N\u00famero total de arestas\n        int adj[MAX_VERTEX][MAX_VERTEX];    //Matriz de fato\n    }Graph;\n\n    //Lista de Adjac\u00eancia\n    typedef struct Node{\n        int vertex;                         //N\u00famero do v\u00e9rtice atual\n        Node *next;                         //Endere\u00e7o do pr\u00f3x n\u00f3\n        Edge *edges;                        //Lista/Vetor de conex\u00f5es\n    }Node;\n\n    typedef struct Graph{\n        int numVertex;                      //Guarda o n\u00famero total de v\u00e9rtices\n        int size;                           //N\u00famero total de arestas\n        Node *adj;                          //Cabe\u00e7a da lista\n    }Graph;\n</code></pre>"},{"location":"apostila/Grafos/#46-busca-em-largura-bfs","title":"4.6 Busca em Largura (BFS)","text":"<p>Se assemelha \u00e0 uma explos\u00e3o, feita para achar menores caminhos. A BFS explora todos os vizinhos de um n\u00f3 antes de avan\u00e7ar para os vizinhos dos vizinhos. O algoritmo usa de uma Fila para controlar as ordens de acesso aos v\u00e9rtices. Ela garante que todos os v\u00e9rtices de uma profundidade d ser\u00e3o explorados antes de explorar v\u00e9rtices de uma profundidade d + 1.</p> <pre><code>    bool visited[MAX_VERTEX];\n\n    void bfs(Graph *G, Edge e)\n    {\n        int v, w;\n        QueuePut(e);\n        visited[e.w] = true;\n\n        while(!QueueEmpty()){\n            e = QueueGet();\n            w = e.w;\n            for(int *l = G-&gt;adj[w]; l != NULL; l = l-&gt;next){\n                int t = l-&gt;vertex;\n                if(visited[t] == false){\n                    QueuePut(Edge{w, t});\n                    visited[t] = true;\n                }\n\n            }\n        }\n    }\n</code></pre>"},{"location":"apostila/Grafos/#47-busca-em-profundidade-dfs","title":"4.7 Busca em profundidade (DFS)","text":"<p>Explora sempre o caminho mais profundo do grafo antes de retroceder. Faz uso de uma Pilha ou de Recurs\u00e3o(que tamb\u00e9m \u00e9 um pilha) para controlar a ordem de acesso aos v\u00e9rtices. Algoritmo guloso, vai em um mesmo caminho at\u00e9 n\u00e3o conseguir mais, boa para BackTracking (fazer uma escolha baseado no que acontecer), usada para encontrar solu\u00e7\u00f5es, como caminhos mais longos ou todos os caminhos poss\u00edveis. Melhor quando \u00e9 preciso encontrar todos os caminhos de um grafo.</p> <ul> <li>Implementa\u00e7\u00e3o 1 (Bruno Ribas):</li> </ul> <pre><code>    bool visited[MAX_VERTEX] = {false};\n\n    void dfsr(Graph *G, Edge e)\n    {\n        int t, w = e.w;\n        visited[w] = true;\n\n        for(t = 0; t &lt; G-&gt;numVertex; t++)\n            if(G -&gt; adj[w][t] != 0)\n                if(visited[t] == false)\n                    dfsr(G, Edge{w, t});\n    }\n</code></pre> <ul> <li>Implementa\u00e7\u00e3o 2:</li> </ul> <pre><code>    void dfsUtil(Graph *G, int vertex, bool visited)\n    {\n        visited[vertex] = true;\n\n        Node *temp = G-&gt;adj[vertex];\n\n        while(temp != NULL)\n        {\n            int adjVertex = temp-&gt;vertex;\n            if(!visited[adjVertex])\n                dfsr2(G, adjVertex, visited);\n            temp = temp-&gt;next;\n        }\n    }\n\n    void dfs(Graph *G, int startVertex)\n    {\n        bool visited[MAX_VERTEX];\n        for(int i = 0; i &lt; MAX_VERTEX; i++)\n            visited[i] = false;\n        dfsUtil(G, startVertex, visited);\n    }\n</code></pre>"},{"location":"apostila/Grafos/#48-problemas-classicos-e-algoritmos-fundamentais","title":"4.8 Problemas cl\u00e1ssicos e Algoritmos Fundamentais","text":""},{"location":"apostila/Grafos/#481-problema-do-menor-caminho","title":"4.8.1 Problema do Menor caminho","text":"<p>Imagine um grafo dirigido ponderado, o caminho de um v\u00e9rtice v at\u00e9 um v\u00e9rtice w \u00e9 o conjunto de arestas que ligam v e w. O peso de um caminho C ser\u00e1 a soma dos pesos da arestas que o comp\u00f5e. C ser\u00e1 m\u00ednimo, se e somente se, nenhum outro caminho com a mesma origem e mesmo destino tiver um peso menor que o peso de C. A dist\u00e2ncia de um v\u00e9rtice v a w \u00e9 o caminho m\u00ednimo de v a w. Se n\u00e3o existe nenhum caminho de v para w, ent\u00e3o a dist\u00e2ncia de v para w \u00e9 infinita. \u00c9 claro que, em geral, a dist\u00e2ncia de v para w \u00e9 diferente da dist\u00e2ncia de w para v.</p> <p>Como encontrar a dist\u00e2ncia de uma origem para qualquer outro v\u00e9rtice de um grafo dirigifo ponderado G?</p> <p>O problema faz sentido, para pesos positivos e negativos, por\u00e9m vamos focar nos positivos primeiro.</p>"},{"location":"apostila/Grafos/#4811-dijkstra","title":"4.8.1.1 Dijkstra","text":"<p>O algoritmo de Dijkstra \u00e9 um algoritmo cl\u00e1ssico de caminho m\u00ednimo, para encontrar o caminho mais curto de um n\u00f3 de origem para todos os outros n\u00f3s de um grafo ponderado com arestas de peso n\u00e3o negativo. </p> <pre><code>void Dijkstra(Graph *g, int start)\n{\n    for (int i = 0; i &lt; g-&gt;numVertex; i++)\n        pa[i] = -1, dist[i] = INFINITY, visited[i] = false;\n\n    pa[start] = start, dist[start] = 0;\n\n    Heap h = PQInit(g-&gt;numVertex);\n\n    for(int i = 0; i &lt; g-&gt;numVertex; i++)\n        PQInsert(h, i, dist[i]);\n\n    while(!PQEmpty(h))\n    {\n        int y = PQPop(h);\n        if(dist[y] == INFINITY) break;\n\n        for(Edge e = g-&gt;edges[y]; e != NULL; e = e.next)\n        {\n            if (visited[e.w]) continue;\n            if (dist[y] + e.weight &lt; dist[e.w])\n            {\n                dist[e.w] = dist[y] + e.weight;\n                PQChange(h, e.w, dist[e.w]);\n                pa[e.w] = y;\n            }\n            visited[y] = true;\n        }\n    } \n    PQFree(h);\n}\n</code></pre> <p>Complexidade: O(E log V) </p>"},{"location":"apostila/Grafos/#4812-bellman-ford","title":"4.8.1.2 Bellman Ford","text":"<p>Assim como o Algoritmo de Dijkstra, o Alogritmo de Bellam Ford, surge para solucionar o problema de menor caminho em um grafo ponderado, por\u00e9m, diferente do Dijkstra, este algoritmo n\u00e3o se limita apenas a grafos ponderados de arestas n\u00e3o negativas, ele tamb\u00e9m funciona para arestas de pesos negativos.</p> <pre><code>bool BellmanFord(Graph g, vertex s, vertex *pa, int *dist)\n{\n   PQInit(g-&gt;numEdges);\n   bool visited[1000];\n   for (vertex u = 0; u &lt; g-&gt;numVertex; ++u)\n      pa[u] = -1, dist[u] = INFINITY, visited[u] = false;\n   pa[s] = s, dist[s] = 0;\n\n   PQInsert( s);\n   visited[s] = true;\n   vertex V = g-&gt;V; \n   PQInsert(V); \n   int k = 0;\n\n   while (true) { \n      vertex v = PQPop( );\n      if (v &lt; V) {\n         for (link a = g-&gt;adj[v]; a != NULL; a = a-&gt;next) {\n            if (dist[v] + a-&gt;c &lt; dist[a-&gt;w]) {\n               dist[a-&gt;w] = dist[v] + a-&gt;c; \n               pa[a-&gt;w] = v;\n               if (visited[a-&gt;w] == false) {\n                  PQInsert( a-&gt;w);\n                  visited[a-&gt;w] = true;\n               }\n            }\n         }\n      } else {\n         if (PQEmpty()) return true; \n         if (++k &gt;= g-&gt;V) return false;\n         PQInsert(V); \n         for (vertex u = 0; u &lt; g-&gt;V; ++u) \n            visited[u] = false;\n      }\n   }\n}\n</code></pre>"},{"location":"apostila/Grafos/#482-problema-das-arvores-geradoras-e-arvores-geradoras-de-custo-minimo-mst","title":"4.8.2 Problema das \u00e1rvores geradoras e \u00e1rvores geradoras de custo m\u00ednimo (MST)","text":"<p>A \u00e1rvore de um grafo G, \u00e9 um subgrafo conexo sem ciclos. Uma \u00e1rvore \u00e9 geradora, se abrange todos os v\u00e9rtices do grafo original G. Como as \u00e1rvores s\u00e3o conexas todo grafo n\u00e3o-dirigido que possui uma \u00e1rvore geradora \u00e9 conexo. E todo grafo conexo n\u00e3o-dirigido \u00e9 dotado de ao menos uma \u00e1rvore geradora. Toda \u00e1rvore geradora de uma grafo n\u00e3o-dirigido com V v\u00e9rtices, tem exatamente V - 1 arestas.</p> <p>Agora, uma \u00e1rvore geradora T \u00e9 m\u00ednima, se nenhuma outra \u00e1rvore geradora de G tem custo menor que T, sendo o custo de T, a soma dos custos/pesos de suas arestas.  \u00c1rvores geradoras m\u00ednimas, tamb\u00e9m chamadas de MSTs (minimum spanning tree), existem, se e somente se, o grafo G \u00e9 conexo.</p> <p>Como encontrar a MST de um grafo G? </p>"},{"location":"apostila/Grafos/#4821-prim","title":"4.8.2.1 Prim","text":"<p>O algoritmo de Prim, \u00e9 um algoritmo para o problema de encontrar uma MST de um grafo ponderado n\u00e3o-dirigido. Os custos das arestas s\u00e3o n\u00fameros arbitr\u00e1rios (positivos e negativos) e s\u00f3 \u00e9 poss\u00edvel encontrar a MST se o grafo \u00e9 conexo. </p> <p>Dado um grafo G, ponderado, n\u00e3o-dirigido e conexo, O algoritmo cultiva uma \u00e1rvore at\u00e9 que se torne geradora e, ao final, ela ser\u00e1 uma MST.  </p> <p>O processo se d\u00e1 apartir de uma \u00e1rvore inicial T  que na primeira itera\u00e7\u00e3o ser\u00e1 um \u00fanico v\u00e9rtice(semente), que \u00e9 escolhido arbitrariamente. </p> <p>Para prosseguir ser\u00e1 necess\u00e1rio definir os conceitos de franja, fronteira, pre\u00e7o e gancho. - A franja de uma sub\u00e1rvore T \u00e9 o conjunto de todas as arestas que ligam um v\u00e9rtice de T \u00e0 algum outro v\u00e9rtice que est\u00e1 fora de T.  - A fronteira de T \u00e9 o conjunto de v\u00e9rtices que n\u00e3o est\u00e3o em T, por\u00e9m s\u00e3o vizinhos aos v\u00e9rtices de T. - O pre\u00e7o de de um v\u00e9rtice v \u00e9 o custo m\u00ednimo de uma aresta que incide em v - O gancho de um v\u00e9rtice v, \u00e9 um v\u00e9rtice w que determina o pre\u00e7o(custo m\u00ednimo) de v, ou seja \u00e9 o vert\u00edce w de menor custo que se liga \u00e0 um v\u00e9rtice v. </p> <p>Portanto, para uma sub\u00e1rvore T de um grafo n\u00e3o-dirigido conexo ponderado G, o algoritmo segue da seguinte forma:</p> <p>Enquanto a franja de T n\u00e3o estiver vazia: 1. Escolha um v\u00e9rtice y na fronteira de T; 2. Seja x o gancho de y; 3. Acrescente a aresta (x, y) e o v\u00e9rtice y a T; 4. Atualize os pre\u00e7os e os ganchos fora de T.</p> <p>Para armazenar os pre\u00e7os podemos usar um vetor <code>preco[]</code> indexado pelos v\u00e9rtices, e para armazenar os pais e os ganchos podemos usar um vetor <code>pa[]</code>, onde, se v est\u00e1 em T, ent\u00e3o <code>pa[v]</code> \u00e9 o pai de v, se v est\u00e1 na fronteira de T ent\u00e3o <code>pa[v]</code> \u00e9 um gancho de v, ou seja se v est\u00e1 na fronteira de T <code>pa[v]</code> \u00e9 um \"pai provis\u00f3rio\" de v, que pode ser alterado conforme o algoritmo progride. </p> <p>O Prim \u00e9 um algoritmo guloso (greedy), portanto ele sempre vai consumir a aresta de menor custo da franja.</p> <p>A partir disso, podemos construir duas implementa\u00e7\u00f5es eficientes do Algoritmo de Prim, uma primeira, eficiente para grafos densos que utiliza apenas os vetores como forma de controle, al\u00e9m de uma segunda mais eficiente para grafos esparsos, que utiliza de uma Fila de Prioridades(Heap) para armazenar os v\u00e9rtices fora T priorizados pelo pre\u00e7o.</p> <p>Obs: Assuma que os vetores j\u00e1 est\u00e3o implementados de maneria global e que <code>dist[]</code> equivale a <code>preco[]</code>.</p> <ul> <li>Implementa\u00e7\u00e3o 1:</li> </ul> <pre><code>void Prim(Graph *g, int start)\n{\n    //Inicializa\u00e7\u00e3o\n    for (int i = 0; i &lt; g-&gt;numVertex; ++v)\n        pa[i] = -1, visited[i] = false, dist[i] = INFINITY;\n\n    //Seta o pr\u00f3prio elemento como visitado e como pai\n    pa[start] = start, visited[start] = true;\n\n    for (Edge *e = g-&gt;edges[0]; e != NULL; e = e-&gt;next)\n    {\n        pa[e-&gt;w] = 0;\n        dist[e-&gt;w] = e-&gt;weight;\n    }\n\n    for(;;) \n    {\n        int min = INFINITY;\n        int y;\n\n        for(int w = 0; w &lt; g-&gt;numVertex; ++w)\n        {\n            if(!visited[w] &amp;&amp; dist[w] &lt; min)\n                min = dist[w], y = w;\n        }\n        if(min == INFINITY)\n            break;\n        visited[y] = true;\n        for(Edge *e = g-&gt;edges[y]; e != NULL; e = e-&gt;next)\n        {\n            if(!visited[e-&gt;w] &amp;&amp; e-&gt;weight &lt; dist[e-&gt;w])\n            {\n                dist[e-&gt;w] = e-&gt;weight;\n                pa[e-&gt;w] = y;\n            }\n        }\n    }\n}\n</code></pre> <p>Complexidade: O(V\u00b2) como o tamanho de grafos densos \u00e9 proporcional a V\u00b2 podemos dizer que a Implementa\u00e7\u00e3o 1 \u00e9 linear para grafos densos.</p> <ul> <li>Implementa\u00e7\u00e3o 2:</li> </ul> <pre><code>void Prim(Graph *g, int start)\n{\n        for (int i = 0; i &lt; g-&gt;numVertex; ++i)\n        pa[i] = -1, visited[i] = false, dist[i] = INFINITY;\n\n    pa[start] = start, visited[start] = true;\n\n    for (Edge *e = g-&gt;edges[0]; e != NULL; e = e-&gt;next)\n        pa[e-&gt;w] = 0, dist[e-&gt;w] = e-&gt;weight;\n\n    Heap *h = PQInit(g-&gt;numVertex);\n    for(int v = 1; v &lt; g-&gt;numVertex; ++v)\n        PQInsert(v, dist);\n\n    while(!PQEmpty(h))\n        {\n        int y = PQPop(dist);\n        if(dist[y] == INFINITY)\n            break;\n        visited[y] = true;\n\n        for(Edge *e = g-&gt;edges[y]; e != NULL; e = e-&gt;next)\n            if(!visited[e-&gt;w] &amp;&amp; e-&gt;weight &lt; dist[e-&gt;w])\n            {\n                dist[e-&gt;w] = e-&gt;weight;\n                PQChange(h, e-&gt;w, dist[e-&gt;w]);\n                pa[e-&gt;w] = y\n            }\n    }\n    PQFree(h);\n}\n</code></pre> <p>A implementa\u00e7\u00e3o 2 utiliza uma [[README#^c7fb0b|Fila de Prioridades]] para armazenar os elementos de menor custo.</p> <p>Complexidade: O(E log V), apenas um pouco pior que a linear, podemos chamar de linear\u00edtmica.</p> <p>Implementa\u00e7\u00e3o 1 X Implementa\u00e7\u00e3o 2</p> <p>Como dito anteriormente, se nos restringirmos a grafos esparsos, a Imp2 \u00e9 mais r\u00e1pida que a Imp1, por\u00e9m em grafos densos, a situa\u00e7\u00e3o se inverte.</p>"},{"location":"apostila/Grafos/#4822-kruskal","title":"4.8.2.2 Kruskal","text":"<p>O algoritmo de Kruskal \u00e9 um algoritmo que busca solucionar o mesmo problema que o algoritmo de Prim, construir a MST de um grafo n\u00e3o-dirigido e ponderado. Por\u00e9m, aqui v\u00eam a primeira diferen\u00e7a. O Prim era aplic\u00e1vel somente para grafos conexos, por\u00e9m se aplicarmos o Kruskal para um grafo com k componentes conexas, obteremos k MSTs distintas, uma para cada componente conexa do grafo.</p> <p>O algoritmo de kruskal tem comportamento guloso(greedy), ele \u00e9 baseado na l\u00f3gica de Ordena\u00e7\u00e3o de Arestas. Cada itera\u00e7\u00e3o come\u00e7a com uma floresta geradora F de um grafo G que \u00e9 incialmente vazia. Enquanto n\u00e3o existirem arestas externas, o algoritmo adiciona uma aresta \u03b1, de peso m\u00ednimo, a F, se e somente se, (1) \u03b1 \u00e9 uma aresta externa a F e (2) F + \u03b1 continua sendo uma floresta, ou seja, a adi\u00e7\u00e3o de \u03b1 a F n\u00e3o gera ciclos. </p> <p>Ao final do procedimento a Floresta F ser\u00e1 conexa desde que G seja conexo. Assim F ser\u00e1 uma MST. </p> <p>O algoritmo tem um funcionamento bem simples, por\u00e9m surge o seguinte problema: como saber se um v\u00e9rtice v j\u00e1 esta ligado a um v\u00e9rtice w? Afim de evitar ciclos. E assim, entra a UFDS (Union-Find-Disjoint-Set) Uma estrutura de dados otimizada que permite verificar e controlar a conectividade de componentes entre sets(conjuntos). </p> <p>A partir disso, podemos implementar o Algoritmo de Kruskal da seguinte forma:</p> <p>Obs: Assuma que a estrutura UFDS e suas respectivas fun\u00e7\u00f5es j\u00e1 est\u00e3o implementadas.</p> <pre><code>void Kruskal(Graph *g, Edge *edges, int numEdges)\n{\n    //Ordena\u00e7\u00e3o do vetor de arestas, pode ser um quick ou um merge\n    mergesort(edges, 0, numEdges);\n\n    Edge *choosenEdges = malloc(sizeof(Edge) * (g-&gt;numVertex - 1));\n    int lenChoosenEdges = 0;\n\n    UFDS *ufds = UFDSInit(g-&gt;numVertex);\n\n    for(int i = 0; i &lt; numEdges &amp;&amp; lenChoosenEdges &lt; g-&gt;numVertex; i++)\n    {\n        int v = edges[i].v;\n        int w = edges[i].w;\n\n        if(!UFDS_SameSet(ufds, v, w))\n            choosenEdges[lenChoosenEdges++] = edges[i], Union(ufds, v, w);\n    }\n    UFDS_Destroy(ufds);\n    return choosenEdges; //Floresta F\n}\n</code></pre> <p>Complexidade: O(E log E).</p>"},{"location":"apostila/HashTable/","title":"1. Hash Table","text":"<p>\u00c9 uma estrutura do tipo chave-valor, onde as chaves s\u00e3o usadas como \u00edndice para achar o elemento desejado, n\u00e3o admite chaves repetidas (tabela de s\u00edmbolos). A chave \u00e9 passada por uma fun\u00e7\u00e3o (normalmente o m\u00f3dulo) onde \u00e9 gerado o \u00edndice/endere\u00e7o na tabela. Esta fun\u00e7\u00e3o tem car\u00e1ter determin\u00edstico ou seja, uma mesma chave sempre gera um mesmo endere\u00e7o. Dessa forma \u00e9 poss\u00edvel acessar qualquer elemento da tabela em grandeza constante O(1).</p> <ul> <li>Fun\u00e7\u00e3o de hashing: <pre><code>int hash(int k, int m){\n    return k % m;\n}\n</code></pre></li> </ul>"},{"location":"apostila/HashTable/#11-colisoes","title":"1.1 Colis\u00f5es","text":"<p>As colis\u00f5es s\u00e3o um problema comum das tabelas hash, ocorrem quando duas chaves diferentes resultam no mesmo endere\u00e7o. Existem v\u00e1rias t\u00e9cnicas para resolver colis\u00f5es.</p>"},{"location":"apostila/HashTable/#111-enderecamento-aberto","title":"1.1.1 Endere\u00e7amento aberto","text":"<p>A estrat\u00e9gia do Endere\u00e7amento aberto, consiste basicamente em: se houver colis\u00e3o, aloque o elemento 1 endere\u00e7o pro lado. Por\u00e9m, caso o n\u00famero de colis\u00f5es seja muito grande a busca passa a ser linear (O(n)), e n\u00e3o mais constante (O(1)).  </p> <p>Por isso \u00e9 interessante definir um n\u00famero m\u00e1ximo de colis\u00f5es para a hash, 10 por exemplo. Assim o tempo continuaria sendo constante (O(10)). Mas, caso o limite de colis\u00f5es esteja sendo muito excedido, h\u00e1 a chance de ter de crescer a tabela, que custa O(n).</p>"},{"location":"apostila/HashTable/#112-double-hash","title":"1.1.2 Double Hash","text":"<p>A estrat\u00e9gia consiste em: quando ocorrer uma colis\u00e3o, aplicar uma nova  fun\u00e7\u00e3o hash ao elemento desta forma, os elementos colididos ficariam mais espa\u00e7ados entre si, diferente da estrat\u00e9gia anterior. Tamb\u00e9m \u00e9 interessante manter um limite de colis\u00f5es, para n\u00e3o preencher a tabela de forma r\u00e1pida.</p> <ul> <li>Exemplo:</li> </ul> <pre><code>#define HASH(K, M) (K % M)\n#define DOUBLE_HASH(K, M) (K % 2M)\n</code></pre> <p>Onde 'K' \u00e9 a chave e 'M' \u00e9 o tamanho da hash table.</p>"},{"location":"apostila/HashTable/#113-encadeamento-separado","title":"1.1.3 Encadeamento separado","text":"<p>Cada posi\u00e7\u00e3o da hash table seria a cabe\u00e7a de uma lista encadeada. Ou seja, sempre que ocorresse uma colis\u00e3o, o elemento simplesmente seria adicionado ao in\u00edcio da lista encadeada. Diferente das outras, nessa estrat\u00e9gia \u00e9 mais dif\u00edcil que o n\u00famero de colis\u00f5es fique muito grande, j\u00e1 que elementos colididos n\u00e3o ocupam a posi\u00e7\u00e3o de outros elementos, tal que, mesmo que em uma chave espec\u00edfica o acesso seja linear, em outros endere\u00e7os ele continuaria a ser constante. Logo, vale avaliar cada caso e verificar se um limite de colis\u00f5es se torna necess\u00e1rio ou n\u00e3o.</p>"},{"location":"apostila/HashTable/#12-bonus-discussao-sobre-complexidades","title":"1.2 B\u00f4nus - Discuss\u00e3o sobre complexidades","text":"Inser\u00e7\u00e3o Remo\u00e7\u00e3o Busca Crescer Vetor n\u00e3o ordenado O(1) O(1) O(n) O(n) Vetor Ordenado O(n) O(n) O(log n) O(n) Lista encadeada n\u00e3o ordenada O(1) O(n) O(n) Din\u00e2mico Lista encadeada ordenada O(n) O(n) O(n) Din\u00e2mico Hash Table O(1) O(1) O(1) O(n) \u00c1rvores bin\u00e1rias O(log n) O(log n) O(log n) Din\u00e2mico"},{"location":"apostila/Quickselect/","title":"Quickselect","text":"<p>QuickSelect \u00e9 um algoritmo de busca inspirado no QuickSort (ordena\u00e7\u00e3o). Ele \u00e9 usado para encontrar o k-\u00e9simo menor elemento em um array n\u00e3o ordenado. Ap\u00f3s uma passagem do algoritmo ele garante que: todos os elementos a direita de um piv\u00f4 ser\u00e3o maiores que ele, e que todos a esquerda ser\u00e3o menores que ele.</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j &lt; high; j++) {\n        if (arr[j] &lt;= pivot) {\n            i++;\n            swap(&amp;arr[i], &amp;arr[j]);\n        }\n    }\n    swap(&amp;arr[i + 1], &amp;arr[high]);\n    return i + 1;\n}\n\nint quickSelect(int arr[], int low, int high, int k) {\n    if (low &lt;= high) {\n        int pivotIndex = partition(arr, low, high);\n\n        if (pivotIndex == k - 1) {\n            return arr[pivotIndex];\n        } else if (pivotIndex &gt; k - 1) {\n            return quickSelect(arr, low, pivotIndex - 1, k);\n        } else {\n            return quickSelect(arr, pivotIndex + 1, high, k);\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"apostila/%C3%81rvoreRedBlack/","title":"2. \u00c1rvore Red Black","text":"<p>\u00c1rvores Red Black s\u00e3o estruturas de \u00e1rvores bin\u00e1rias de busca modificadas, para ficarem constantemente balanceadas, evitando o problema das \u00e1rvores convencionais, que dependendo da ordem de inser\u00e7\u00e3o podem ficar com complexidade linear (O(n)) em vez de complexidade logar\u00edtmica (O(log n)), perdendo toda a raz\u00e3o de usar \u00e1rvores e n\u00e3o outras estruturas. Cada n\u00f3 da \u00e1rvore tem uma cor, vermelha ou preta, e essas cores s\u00e3o usadas para aplicar as regras que garantem o balanceamento da \u00e1rvore. N\u00e3o admite chaves repetidas (tabela de s\u00edmbolos).</p>"},{"location":"apostila/%C3%81rvoreRedBlack/#21-structs","title":"2.1 Structs","text":"<pre><code>typedef struct Node{\n    int data;\n    struct Node *right;\n    struct Node *left;\n    bool red;\n}Node;\n\ntypedef struct Tree{\n    Node *root;\n}Tree;\n</code></pre>"},{"location":"apostila/%C3%81rvoreRedBlack/#22-regras-da-redblack","title":"2.2 Regras da RedBlack","text":"<p>Os n\u00f3s podem ser do tipo acima. Todo novo n\u00f3 inserido \u00e9 inserido com vermelho. E as seguintes regras t\u00eam de sempre ser seguidas:</p> <ol> <li>Nenhum n\u00f3 vermelho pode estar \u00e0 direita do n\u00f3 pai</li> <li>N\u00e3o pode ter dois n\u00f3s vermelhos \u00e0 esquerda seguidos</li> <li>Um n\u00f3 pai n\u00e3o pode ter os 2 filhos vermelhos</li> </ol> <p>Assim que alguma das regras forem quebradas algum algoritmo deve ser chamado para resolver o problema: </p> <ol> <li>Quando a regra \"1\" for quebrada deve ser aplicado um rotateLeft() para rotacionar o n\u00f3 vermelho para \u00e0 esquerda. </li> <li>Quando a regra \"2\" for quebrada deve ser aplicado um rotateRight() para rotacionar o  elemento pai para \u00e0 direita, de forma que o elemento do meio se torne o novo pai.</li> <li>Quando a regra \"3\" for quebrada deve ser aplicado um flipColors() para trocar as cores dos n\u00f3s filhos com o n\u00f3 pai, pintando os n\u00f3s filhos de preto e o n\u00f3 pai de vermelho.</li> </ol> <p>Observa\u00e7\u00e3o:  A cor da raiz n\u00e3o importa .</p>"},{"location":"apostila/%C3%81rvoreRedBlack/#221-algoritmos-de-balanceamento","title":"2.2.1 Algoritmos de balanceamento","text":"<pre><code>    void flipColors(Node *root){\n        h-&gt;left-&gt;red = !h-&gt;left-&gt;red;\n        h-&gt;right-&gt;red = !h-&gt;right-&gt;red;\n        h-&gt;red = !h-&gt;red;\n    }\n\n    Node *rotateLeft(Node *root)\n    {\n        Node *newroot = root-&gt;right;      //Novo no recebe a direita da raiz\n        root-&gt;right = newroot-&gt;left;      //A direita da raiz recebe a arvore \u00e0 esquerda da nova raiz\n        newroot-&gt;left = root;             //A esquerda da nova raiz recebe a raiz antiga\n        newroot-&gt;red = root-&gt;red;\n        root-&gt;red = true;\n\n        return newroot;\n    }\n\n    Node *rotateRight(Node *root)\n    {\n        Node *newroot = root-&gt;left;     //Novo no recebe a esquerda da raiz\n        root-&gt;left = newroot-&gt;right;    //A esquerda da raiz recebe a arvore \u00e0 direita da nova raiz\n        newroot-&gt;right = root;          //A direita da nova raiz recebe a raiz antiga\n        newroot-&gt;red = root-&gt;red;\n        root-&gt;red = true;\n\n        return newroot;\n    }\n</code></pre>"},{"location":"apostila/%C3%81rvoreRedBlack/#222-insercoes-em-arvore-red-black","title":"2.2.2 Inser\u00e7\u00f5es em \u00c1rvore Red Black","text":"<ul> <li>Exemplo de inser\u00e7\u00e3o em uma RedBlack com a seguinte sequ\u00eancia:<code>10, 15, 5, 3, 2, 20, 25, 30, 20.</code></li> </ul> <pre><code>graph LR;\n\n    subgraph I1[Inser\u00e7\u00e3o do 10]\n    A(10) --&gt; B(NULL) &amp; C(NULL)\n    end\n\n    subgraph I2[Inser\u00e7\u00e3o do 15]\n    A2(10) --&gt; B2(NULL) &amp; C2(15)\n    end\n\n    subgraph I3[rotateLeft]\n    A3(15) --&gt; C3(10) &amp; B3(NULL)\n    end\n\n    subgraph I4[Inser\u00e7\u00e3o do 5]\n    A4(15)--&gt; B4(10) --&gt; C4(5)\n    A4(15) --&gt; D4(NULL)\n    B4(10) --&gt; E4(NULL)\n    end\n\n    subgraph I5[rotateRight]\n    A5(10) --&gt; B5(5) &amp; C5(15)\n    end\n\n    subgraph I6[flipColors]\n    A6(10) --&gt; B6(5) &amp; C6(15)\n    end\n\n    subgraph I7[Final Tree]\n    a7(10) --&gt; b7(3) &amp; c7(20)\n    b7(3) --&gt; d7(2) &amp; e7(5)\n    c7(20) --&gt; f7(15) &amp; g7(30)\n    g7(30) --&gt; h7(25)\n    end\n\n    classDef myNodeStyle fill:#FFF,stroke-width:2px, rx: 10px, ry 10px;\n\n\n    style C2 fill: #FF272A, \n    style C3 fill: #FF272A\n    style B4 fill: #FF272A\n    style C4 fill: #FF272A\n    style B5 fill: #FF272A\n    style C5 fill: #FF272A\n    style A6 fill: #FF272A\n    style h7 fill: #FF272A\n\n    style I1 fill: #FFFFFF00, stroke:#FFF, stroke-width: 1px;\n    style I2 fill: #FFFFFF00, stroke:#FFF, stroke-width: 1px;\n    style I3 fill: #FFFFFF00, stroke:#FFF, stroke-width: 1px;\n    style I4 fill: #FFFFFF00, stroke:#FFF, stroke-width: 1px;\n    style I5 fill: #FFFFFF00, stroke:#FFF, stroke-width: 1px;\n    style I6 fill: #FFFFFF00, stroke:#FFF, stroke-width: 1px;\n    style I7 fill: #FFFFFF00, stroke:#FFF, stroke-width: 1px;\n\n\n    In\u00edcio --&gt; I1 --&gt; I2 --&gt; I3;\n    I4 --&gt; I5 --&gt; I6 --&gt; I7;    \n</code></pre> <ul> <li>No exemplo \u00e9 poss\u00edvel visualizar todos os os casos em que alguma das regras \u00e9 quebrada, e como \u00e9 o comportamento das respectivas fun\u00e7\u00f5es de \"corre\u00e7\u00e3o\" da \u00e1rvore, al\u00e9m do formato final da \u00e1rvore ap\u00f3s todas as inser\u00e7\u00f5es.</li> </ul>"},{"location":"apostila/%C3%81rvoreRedBlack/#223-algoritmos-de-insercao","title":"2.2.3 Algoritmos de Inser\u00e7\u00e3o","text":"<pre><code>    bool isRed(Node *n)\n    {\n        if(n == NULL) \n            return false;\n        if(n-&gt;red)\n            return true;\n\n        return false;    \n    }\n\n    Node *newnode(bool red, Node *left, Node *right, int data)\n    {\n        Node *nv = malloc(sizeof(Node));\n        nv-&gt;red = red;\n        nv-&gt;left = left\n        nv-&gt;right = right;\n        nv-&gt;data = data;\n\n        return nv;\n    }\n\n    Node* insert(Node *root, int data)\n    {\n        if(root == NULL) \n            return newnode(true, NULL, NULL, data);\n\n        //Inser\u00e7\u00e3o comum de uma BST\n        if(less(data, root-&gt;data)){\n            root-&gt;left = insert(root-&gt;left, data);\n        }\n        else if(less(root-&gt;data, data)){\n            root-&gt;right = insert(root-&gt;right, data);\n        }\n        else{\n            root-&gt;data = data\n        }\n\n        //Manipula\u00e7\u00f5es da Red Black\n        //Regra 1\n        if(!isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;right)) \n            root = rotateLeft(root);\n        //Regra 2\n        if(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;left-&gt;left)) \n            root = rotateRight(root);\n        //Regra 3\n        if(isRed(root-&gt;left) &amp;&amp; isRed(root-&gt;right))         \n            flipColors(root)\n    }\n</code></pre>"},{"location":"apostila/%C3%81rvoreRedBlack/#23-alturas-de-uma-red-black","title":"2.3 Alturas de uma Red Black","text":"<p>Em suma existem dois tipos de altura associadas \u00e0 uma \u00e1rvore red black, que s\u00e3o a Altura total e a Altura Negra.</p>"},{"location":"apostila/%C3%81rvoreRedBlack/#231-altura-total","title":"2.3.1 Altura Total","text":"<p>A altura total refere-se \u00e0 dist\u00e2ncia de qualquer n\u00f3 folha at\u00e9 a raiz da \u00e1rvore.</p>"},{"location":"apostila/%C3%81rvoreRedBlack/#funcoes","title":"Fun\u00e7\u00f5es:","text":"<p><pre><code>    int alturaTotal(Tree *root)\n    {\n        int count = 0;\n        while(root != NULL)\n        {\n            count++;\n            root = root-&gt;left;\n        }\n        return count;\n    }\n</code></pre> <pre><code>    int alturaTotal(Tree *root, int h)\n    {\n        if(root == NULL)\n            return h;\n\n        int esq = alturaTotal(root-&gt;left, h + 1);\n        int dir = alturaTotal(root-&gt;right, h + 1);\n\n        if(esq &gt; dir)\n            return esq;\n\n        return dir;\n    }\n</code></pre></p>"},{"location":"apostila/%C3%81rvoreRedBlack/#232-altura-negra","title":"2.3.2 Altura Negra","text":"<p>Altura Negra refere-se \u00e0 dist\u00e2ncia de um n\u00f3 folha preto at\u00e9 a raiz.</p> <ul> <li>Fun\u00e7\u00e3o:</li> </ul> <pre><code>    int alturaNegra(Tree *root, int h)\n    {\n        if (root == NULL) \n            return h;\n\n        int esq = alturaNegra(root-&gt;left, h + 1);\n        int dir = alturaNegra(root-&gt;right, h + 1);\n\n        if(root-&gt;red == false &amp;&amp; esq &gt; dir)\n            return esq; \n        else if(root-&gt;red == false &amp;&amp; dir &gt; esq)\n            return dir;\n    }\n</code></pre>"},{"location":"apostila/%C3%81rvoreRedBlack/#24-bonus-arvore-2-3","title":"2.4 B\u00f4nus - \u00c1rvore 2-3","text":"<p>\u00c1rvores 2-3 s\u00e3o estruturas similares a as \u00e1rvores red black. Tamb\u00e9m s\u00e3o constantemente balanceadas (altura = log n). Cont\u00e9m n\u00f3s de 3 tipos, sendo um deles do tipo \"fantasma\".</p> <ol> <li>Tipo 2: dois filhos (cont\u00e9m apenas 1 elemento);</li> <li>Tipo 3: tr\u00eas filhos (cont\u00e9m 2 elementos);</li> <li> <p>Tipo 4: quatro filhos (cont\u00e9m 3 elementos. Tempor\u00e1rio, sempre que surge um n\u00f3 deste tipo ele \u00e9 quebrado e o elemento do meio se torna a nova raiz e agrupa os outros dois elementos a esquerda(menor) e a direita(maior)).</p> </li> <li> <p>A \u00e1rvore final do diagrama, poderia ser representada da seguinte forma em um modelo de \u00e1rvore 2-3:</p> </li> </ol> <pre><code>graph TD;\n    a7((10)) --&gt; b7(3)\n    a7(10) --&gt; c7(20)\n    b7(3) --&gt; z7(NULL) &amp; e7(5)\n    e7(5) --&gt; y7(NULL) &amp; x7(NULL)\n    c7(20) --&gt; f7(15)\n    c7(20) --&gt; g7(30 25)\n    f7 --&gt; w7(NULL) &amp; u7(NULL)\n    g7(30 25) --&gt; h7(NULL)\n    g7(30 25) --&gt; i7(NULL)\n    g7(30 25) --&gt; j7(NULL)\n</code></pre>"},{"location":"exec/01_desenferrujando/","title":"Lista I - Desenferrujando para o semestre","text":""},{"location":"exec/01_desenferrujando/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Aqui se encontram as solu\u00e7\u00f5es dos problemas referentes \u00e0 1\u00aa lista de exerc\u00edcios e os PDFs de cada problema associados ao t\u00edtulo.</p>"},{"location":"exec/01_desenferrujando/#problemas","title":"Problemas","text":""},{"location":"exec/01_desenferrujando/#ola-mundo","title":"Ol\u00e1 Mundo","text":"olaMundo.c<pre><code>    #include &lt;stdio.h&gt;\n\n    int main()\n    {\n        printf(\"Ola mundo\\n\");\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#soma-2","title":"Soma 2","text":"soma2.c<pre><code>    #include&lt;stdio.h&gt;\n\n    int main(){\n\n        int n1, n2;\n        scanf(\"%d\", &amp;n1);\n        scanf(\"%d\", &amp;n2);\n\n        printf(\"%d\", n1 + n2);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#soma-n","title":"Soma N","text":"somaN.c<pre><code>    #include &lt;stdio.h&gt;\n\n    int main(){\n\n        int n, soma = 0;\n        scanf(\"%d\", &amp;n);\n\n        for(int i=0; i &lt; n; i++){\n            int x;\n            scanf(\"%d\", &amp;x);\n            soma = soma + x;\n        }\n        printf(\"%d\\n\", soma);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#eof","title":"EOF","text":"eof.c<pre><code>    #include &lt;stdio.h&gt;\n\n    int main(){\n\n        int n, contador = 0;\n        while(scanf(\"%d\", &amp;n) != EOF){\n            contador++;\n        }\n        printf(\"%d\\n\", contador);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#viagem-aconselha","title":"Viagem aconselha","text":"viagem.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct {\n        int codigo;\n        int nota;\n    }Restaurante;\n\n    int main(){\n\n        int dia = 1;\n        while(1){\n            int n;\n            if(scanf(\"%d\", &amp;n) == EOF) break;\n\n            Restaurante *rest = malloc(n * sizeof(Restaurante));\n\n            for(int i=0; i&lt;n; i++){\n                scanf(\"%d %d\", &amp;rest[i].codigo, &amp;rest[i].nota);\n            }\n\n            int menorCod = -1;\n            int maiorNota = -1;\n\n            for(int i=0; i&lt;n; i++){\n                if(rest[i].nota &gt; maiorNota || (rest[i].nota == maiorNota &amp;&amp; rest[i].codigo &lt; menorCod)){\n\n                    maiorNota = rest[i].nota;\n                    menorCod = rest[i].codigo;\n                }\n            }\n\n            printf(\"Dia %d\\n\", dia++);\n            printf(\"%d\\n\\n\", menorCod);\n\n            free(rest);\n        }\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#desfazer-no-editor","title":"Desfazer no editor","text":"desfazer.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    #define MAX_SIZE 100\n\n    typedef struct Node{\n        char str[MAX_SIZE];\n        struct Node *next;\n    }Node;\n\n    typedef struct Stack{\n        Node *top;\n    }Stack;\n\n    void startStack(Stack *s){\n        s-&gt;top == NULL;\n    }\n\n    int insert(Stack *s, char *str){\n        Node *n  = malloc(sizeof(Node));\n        if(n == NULL){\n            printf(\"Erro de aloca\u00e7\u00e3o\\n\");\n            return -1;\n        }\n        strcpy(n-&gt;str, str);\n        n-&gt;next = s-&gt;top;\n        s-&gt;top = n;\n        return 1;\n    }\n\n    const char* pop(Stack *s){\n        if(s-&gt;top == NULL) return \"NULL\";\n        char *frase = strdup(s-&gt;top-&gt;str);\n\n        Node *temp = s-&gt;top;\n        s-&gt;top = s-&gt;top-&gt;next;\n        free(temp);\n        return frase;\n    }\n\n    int main(){\n\n        Stack *s = malloc(sizeof(Stack));\n        if(s == NULL){\n            printf(\"Error to create Stack\");\n            return -1;\n        }\n        startStack(s);\n\n        char action[20];\n        while(scanf(\"%s\", action) != EOF) {\n            if(strcmp(action, \"inserir\") == 0){\n                char str[MAX_SIZE];\n                scanf(\"%[^\\n]\", str);\n                insert(s, str);\n            }else if(strcmp(action, \"desfazer\") == 0){\n                printf(\"%s\\n\", pop(s));\n            }\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#cofrinho-da-vo-vitoria","title":"Cofrinho da v\u00f3 Vit\u00f3ria","text":"cofrinho.c<pre><code>    #include &lt;stdio.h&gt;\n\n    int main(){\n\n        int n = 0;\n        int c = 1;\n\n        while(1){\n\n            scanf(\"%d\", &amp;n);\n            if (n == 0) break;\n            int zt = 0, jt = 0;\n\n            for(int i=0; i&lt;n; i++){\n                int z, j;\n                scanf(\"%d %d\", &amp;j, &amp;z);\n\n                    zt += z;\n                    jt += j;\n\n                    if(i == 0) printf(\"Teste %d\\n\", c++);\n                    printf(\"%d\\n\", jt - zt);\n            }\n            printf(\"\\n\");\n        }\n\n        return 0;   \n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#ultrapassa-minimamente","title":"Ultrapassa Minimamente","text":"ultrapassa.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    void ultrapassaMin(int *v, int ini, int ifi, int ls, int soma){\n\n        if(ini &gt; ifi) return;\n\n        soma += v[ini++];\n\n        if (soma &gt; ls){\n            soma = 0;\n            ultrapassaMin(v, ini, ifi, ls, soma);\n            printf(\"%d\\n\", v[ini - 1]);\n        }else{\n            ultrapassaMin(v, ini, ifi, ls, soma);\n        }\n\n    }\n\n    int main(){\n\n        int v_size = 1000;\n        int *v = malloc(sizeof(int) * v_size);\n        int n;\n        int i =0;\n\n        while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n != 0){\n            v[i] = n;\n            i++;\n            if(n &gt;= v_size){\n                v_size *= 2;\n                v = realloc(v, sizeof(int) * v_size);\n            }\n        }\n\n        int soma_min;\n        scanf(\"%d\", &amp;soma_min);\n\n        ultrapassaMin(v, 0, i - 1, soma_min, 0);\n\n        return 0;\n\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#soma-string","title":"Soma string","text":"somaString.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n    #include &lt;ctype.h&gt;\n\n    int main (){\n\n        int n;\n\n        scanf(\"%d\", &amp;n);\n        getchar(); //consome new line\n\n        for(int i=0; i &lt; n; i++){\n            int soma = 0;\n            char c;\n\n            while((c = getchar()) != '\\n'){\n                if(isdigit(c)){\n                    soma += c - '0'; // converte char para int\n                }\n            }\n            printf(\"%d\\n\", soma);  \n            }\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#quem-vai-ser-reprovado","title":"Quem vai ser reprovado ?","text":"reprovado.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n\n    int main(){\n\n        int n;\n        int c = 1;\n\n        while(scanf(\"%d\", &amp;n) != EOF){\n            char nome[21];\n            int nota;\n            char rep[21];\n            int minnota = 11;\n\n            for(int i=0; i &lt; n; i++){\n                scanf(\"%s %d\", nome, &amp;nota);\n\n                if(nota &lt; minnota || (nota == minnota &amp;&amp; strcmp(nome, rep) &gt; 0)){\n                    minnota = nota;\n                    strcpy(rep, nome);\n                }\n            }\n            printf(\"Instancia %d\\n\", c++);  \n            printf(\"%s\\n\\n\", rep);\n        }\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#frequencia-na-aula","title":"Frequ\u00eancia na aula","text":"frequencia.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n    #include &lt;string.h&gt;\n\n    int vet[1000001];\n\n    int main(){\n\n        int n;\n        int al = 0;\n        int reg;\n\n        scanf(\"%d\", &amp;n);\n\n        for(int i=n; i != 0; i--){\n            scanf(\"%d\", &amp;reg);\n            vet[reg]++;\n        }\n\n        for(int i=0; i &lt; 1000001; i++){\n            al += vet[i] &gt; 0;\n        }\n\n        printf(\"%d\\n\", al);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#analise-de-degustacao","title":"An\u00e1lise de degusta\u00e7\u00e3o","text":"degusta.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct Entrada{\n        int qtd;\n        char c;\n        int pos;\n    }Entrada;\n\n    int compararEntradas(const void *a, const void *b){\n\n        const Entrada *entA = (const Entrada *)a;\n        const Entrada *entB = (const Entrada *)b;\n\n        if (entA-&gt;qtd &gt; entB-&gt;qtd){\n            return -1;\n        }else if(entA-&gt;qtd &lt; entB-&gt;qtd){\n            return 1;\n        }\n\n        return 0;\n    }\n\n    int main(){    \n        char s[100001];\n        fgets(s, sizeof(s), stdin);\n\n        int len = strlen(s);\n\n        //Entrada *entrada = (Entrada *)malloc(sizeof(Entrada) * len);\n\n        Entrada entrada[len];\n        if (s[len - 1] == '\\n') {\n            s[len - 1] = '\\0'; \n            len--;\n        }\n\n        int i = 0;\n        int num = 0;\n\n        while(i &lt; len){\n            char c = s[i];\n            int tam = 0;\n            int ini = i;\n\n            while(i &lt; len &amp;&amp; s[i] == c){\n                tam++;\n                i++;\n            }\n\n            entrada[num].c = c;\n            entrada[num].pos = ini;\n            entrada[num].qtd = tam;\n            num++;\n        }\n\n        qsort(entrada, num, sizeof(Entrada), compararEntradas);\n\n        for(int i=0; i&lt;num; i++){\n            printf(\"%d %c %d\\n\", entrada[i].qtd, entrada[i].c, entrada[i].pos);\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#numero-proibido","title":"N\u00famero proibido","text":"numProibido.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    void merge(int arr[], int left[], int right[], int left_s, int right_s){\n        int i=0, j=0, k=0;\n\n        while(i &lt; left_s &amp;&amp; j &lt; right_s){\n            if(left[i] &lt;= right[j]){\n                arr[k++] = left[i++];\n            }else {\n                arr[k++] = right[j++];\n            }\n        }\n\n        while(i &lt; left_s){\n            arr[k++] = left[i++];\n        }\n\n        while(j &lt; right_s){\n            arr[k++] = right[j++];\n        }\n    }\n\n    void mergeSort(int arr[], int size){\n        if(size &lt;= 1){\n            return;\n        }\n\n        int mid = size / 2;\n        int left[mid];\n        int right[size - mid];\n\n        for(int i = 0; i &lt; mid; i++) left[i] = arr[i];\n\n        for(int i = mid; i &lt; size; i++) right[i - mid] = arr[i];\n\n        mergeSort(left, mid);\n        mergeSort(right, size - mid);\n\n        merge(arr, left, right, mid, size - mid);\n    }\n\n    int buscaBinaria(int arr[], int size, int key){\n        int left = 0;\n        int right = size - 1;\n\n        while(left &lt;= right){\n        int mid = left + (right - left) / 2;\n\n            if(arr[mid] == key){\n                return mid;\n            }else if (arr[mid] &lt; key){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n\n        return -1;\n\n    }\n\n    int main(){\n\n        int n = 0;\n        scanf(\"%d\", &amp;n);\n\n        int nmp[n];\n        int t;\n\n        for(int i=0; i &lt; n; i++){\n            scanf(\"%d\", &amp;nmp[i]);\n        }\n\n        mergeSort(nmp, n);\n\n        while(scanf(\"%d\", &amp;t) != EOF){\n            if(buscaBinaria(nmp, n, t) &lt; 0){\n                printf(\"nao\\n\");\n            }else{\n                printf(\"sim\\n\");\n            }\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#notas-da-turma","title":"Notas da Turma","text":"notas.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct celula {\n      char matricula[10];\n      double mediaAtividades;\n      double mediaProvas;\n      struct celula *prox;\n    } celula;\n\n    void relatorioMediaAtividades (celula *le, celula *l1, celula *l2, double media){\n\n        celula *aux = le-&gt;prox;\n        celula *auxl1 = l1;\n        celula *auxl2 = l2;\n\n        l1-&gt;prox = NULL;\n        l2-&gt;prox = NULL;\n\n        while(aux != NULL){\n            if(aux-&gt;mediaAtividades &gt; media){\n                auxl2-&gt;prox = aux;\n                auxl2 = aux;\n            }else{\n                auxl1-&gt;prox = aux;\n                auxl1 = aux;\n            }\n            aux = aux-&gt;prox;\n        }\n\n        auxl1-&gt;prox = NULL;\n        auxl2-&gt;prox = NULL;\n    }\n</code></pre>"},{"location":"exec/01_desenferrujando/#mesclar-listas","title":"Mesclar Listas","text":"mesclarListas.c<pre><code>    #include &lt;stdio.h&gt;\n\n    typedef struct celula {\n       int dado;\n       struct celula *prox;\n    } celula;\n\n    void mescla_listas (celula *l1, celula *l2, celula *l3){\n\n        l3-&gt;prox = NULL;\n        celula *auxl1 = l1-&gt;prox;\n        celula *auxl2 = l2-&gt;prox;\n        celula *auxl3 = l3;\n\n        while(auxl1 != NULL &amp;&amp; auxl2 != NULL){\n            if(auxl1-&gt;dado &lt;= auxl2-&gt;dado){\n                auxl3-&gt;prox = auxl1;\n                auxl1 = auxl1-&gt;prox;\n            }else{\n                auxl3-&gt;prox = auxl2;\n                auxl2 = auxl2-&gt;prox;\n            }\n            auxl3 = auxl3-&gt;prox;\n        }\n\n        while (auxl1 != NULL) {\n            auxl3-&gt;prox = auxl1;\n            auxl1 = auxl1-&gt;prox;\n            auxl3 = auxl3-&gt;prox;\n        }\n\n        while (auxl2 != NULL) {\n            auxl3-&gt;prox = auxl2;\n            auxl2 = auxl2-&gt;prox;\n            auxl3 = auxl3-&gt;prox;\n        }\n    }\n</code></pre>"},{"location":"exec/02_hashing/","title":"Lista II - Hashing","text":""},{"location":"exec/02_hashing/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Aqui se encontram as solu\u00e7\u00f5es dos problemas referentes \u00e0 2\u00aa lista de exerc\u00edcios, focada na estrutura de dados hash table, e os PDFs de cada problema associados ao t\u00edtulo.</p>"},{"location":"exec/02_hashing/#problemas","title":"Problemas","text":""},{"location":"exec/02_hashing/#desfile-dos-patos","title":"Desfile dos patos","text":"desfileDosPatos.c<pre><code>    #include &lt;stdio.h&gt;\n\n\n    int main(){\n\n        int n = 0;\n        while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n != 0){\n\n            int colors[1000001] = {0};\n            int max = 0;\n            int colorMax = -1;\n\n            for(int i=0; i&lt;n; i++){\n                int color;\n                scanf(\"%d\", &amp;color);\n                colors[color]++;         //Inicio de conceito de tabela hash\n\n                if(colors[color] &gt; max){\n                    colorMax = color;\n                    max = colors[color];\n                }\n\n            }\n            printf(\"%d\\n\", colorMax);\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/02_hashing/#diga-me-a-frequencia","title":"Diga me a frequ\u00eancia","text":"B-digaMeAFrequencia.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n    #include &lt;string.h&gt;\n\n    typedef struct Contagem{\n        char c;\n        int cont;\n    }Contagem;\n\n    int comparar(const void *a, const void *b)\n    {\n        const Contagem *contA = (const Contagem *)a;\n        const Contagem *contB = (const Contagem *)b;\n\n        if(contA-&gt;cont &gt; contB-&gt;cont){\n            return  1;\n        }else if(contB-&gt;cont &gt; contA-&gt;cont){\n            return -1;\n        }\n\n        if(contA-&gt;c &gt; contB-&gt;c){\n            return 1;\n        }else if (contB-&gt;c &gt; contA-&gt;c){\n            return -1;\n        }\n\n        return 0;\n    }\n\n\n    int main(){\n        char line[1001];\n\n        while(scanf(\"%s\", line) != EOF)\n        {\n            Contagem arr[128] = {0};\n            int n = strlen(line);\n\n            for(int i=0; i &lt; n; i++){\n\n                char c = line[i];\n\n                arr[c].c = c;\n                arr[c].cont++;       \n            }\n\n            qsort(arr, 128, sizeof(Contagem), comparar);        \n\n            for (int i = 0; i &lt; 128; i++) {\n                if(arr[i].cont &gt; 0){\n                    printf(\"%d %d\\n\", arr[i].c, arr[i].cont);\n                }\n            }\n            printf(\"\\n\");\n        }   \n\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/02_hashing/#eleicao-ursal","title":"Elei\u00e7\u00e3o U.R.S.A.L","text":"C-eleicaoURSAL.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct \n    {\n        int codigo;\n        int votos;\n    } Candidato;\n\n    #define codigo(A) (A.codigo)\n    #define votos(A) (A.votos)\n    #define less(A,B) ((votos(A) == votos(B)) ? (codigo(A) &gt; codigo(B)) : (votos(A) &gt; votos(B))) //(votos(A) &gt; votos(B)) \n    #define exch(A,B) { Candidato tt; tt = A; A = B; B = tt; }\n    #define cmpexch(A,B) {if (less(B,A)) exch(A,B)}\n\n\n    int separa(Candidato *v, int l, int r)\n    {\n        Candidato pivo = v[r];\n        int j = l;\n        for (int k = l; k &lt; r; k++)\n            if (less(v[k], pivo))\n            {\n                exch(v[k], v[j]);\n                j++;\n            }\n        exch(v[j], v[r]);\n        return j;\n    }\n\n    void quicksortM3(Candidato *v, int l, int r)\n    {\n        if (r - l &lt;= 16)\n            return;\n\n        exch(v[(l + r) / 2], v[r - 1]);\n        cmpexch(v[l], v[r - 1]);\n        cmpexch(v[l], v[r]);\n        cmpexch(v[r - 1], v[r]);\n\n        int m = separa(v, l, r);\n        quicksortM3(v, l, m - 1);\n        quicksortM3(v, m + 1, r);\n    }\n\n    void insertionsort(Candidato *v, int l, int r)\n    {\n        for (int i = r; i &gt; l; i--)\n            cmpexch(v[i - 1], v[i]);\n\n        for (int i = l + 2; i &lt;= r; i++)\n        {\n            int j = i;\n            Candidato m = v[j];\n            while (less(m, v[j - 1]))\n            {\n                v[j] = v[j - 1];\n                j--;\n            }\n            v[j] = m;\n        }\n    }\n\n    void quicksort(Candidato *v, int l, int r)\n    {\n        quicksortM3(v, l, r);\n        insertionsort(v, l, r);\n    }\n\n\n    int main(void)\n    {\n        int S, F, E;\n        scanf(\"%d %d %d\", &amp;S, &amp;F, &amp;E);\n\n        int candidato;\n\n        Candidato *presidente = calloc(100, sizeof(Candidato)), \n             *senador = calloc(1000, sizeof(Candidato)), \n             *depFed = calloc(10000, sizeof(Candidato)), \n             *depEst = calloc(100000, sizeof(Candidato));\n\n        int val = 0, nulos = 0;\n        int tot = 0;\n\n        while (scanf(\"%d\", &amp;candidato) == 1)\n        {\n            if (candidato &gt; 0)\n            {\n                val++;\n\n                if (candidato &gt;= 10000)\n                {\n                    if (depEst[candidato].codigo == 0) depEst[candidato].codigo = candidato; \n                    depEst[candidato].votos++;\n                }\n                else if (candidato &gt;= 1000)\n                {\n                    if (depFed[candidato].codigo == 0) depFed[candidato].codigo = candidato; \n                    depFed[candidato].votos++;\n                }\n\n                else if (candidato &gt;= 100)\n                {\n                    if (senador[candidato].codigo == 0) senador[candidato].codigo = candidato; \n                    senador[candidato].votos++;\n                }\n                else\n                {\n                    if (presidente[candidato].codigo == 0) presidente[candidato].codigo = candidato;\n                    presidente[candidato].votos++;\n                    tot++;\n                }\n            }\n            else\n                nulos++;\n        }\n\n        int aux = 0;\n        for (int i = 0; i &lt; 100; i++)\n            if (presidente[i].votos)\n                presidente[aux++] = presidente[i];\n        quicksort(presidente, 0, aux);\n\n        aux = 0;\n        for (int i = 0; i &lt; 1000; i++)\n            if (senador[i].votos)\n                senador[aux++] = senador[i];\n        quicksort(senador, 0, aux);\n\n        aux = 0;\n        for (int i = 0; i &lt; 10000; i++)\n            if (depFed[i].votos)\n                depFed[aux++] = depFed[i];\n        quicksort(depFed, 0, aux);\n\n        aux = 0;\n        for (int i = 0; i &lt; 100000; i++)\n            if (depEst[i].votos)\n                depEst[aux++] = depEst[i];\n        quicksort(depEst, 0, aux);\n\n        printf(\"%d %d\\n\", val, nulos);\n\n        if ((float) presidente[0].votos/tot &gt;= 0.51)\n            printf(\"%d\\n\", presidente[0].codigo);\n        else\n            printf(\"Segundo turno\\n\");\n\n        for (int i = 0; i &lt; S; i++)\n            printf(\"%d \", senador[i].codigo);   \n        printf(\"\\n\");\n\n        for (int i = 0; i &lt; F; i++)\n            printf(\"%d \", depFed[i].codigo);   \n        printf(\"\\n\");\n\n        for (int i = 0; i &lt; E; i++)\n            printf(\"%d \", depEst[i].codigo);   \n        printf(\"\\n\");\n\n        free(presidente);\n        free(senador);\n        free(depFed);\n        free(depEst);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/02_hashing/#notas-curiosas","title":"Notas curiosas","text":"D-notasCuriosas.c<pre><code>    #include &lt;stdio.h&gt;\n\n\n    int main(){\n        int n;\n        scanf(\"%d\", &amp;n);\n\n        int notas[1001] = {0};\n        int nota;\n        int majorNota = 0;\n        int notaMax = 0;\n\n        for(int i=0; i &lt; n; i++)\n        {\n            scanf(\"%d\", &amp;nota);\n            notas[nota]++;\n            if(notas[nota] &gt; notaMax)\n            {\n                notaMax = notas[nota];\n                majorNota = nota;\n            }else if(notas[nota] == notaMax &amp;&amp; nota &gt; majorNota)\n            {\n                majorNota = nota;\n            }\n        }    \n        printf(\"%d\\n\", majorNota);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/02_hashing/#notas","title":"Notas","text":"E-notas.c<pre><code>    #include &lt;stdio.h&gt;\n\n\n    int main(){\n        int n;\n        scanf(\"%d\", &amp;n);\n\n        int notas[101] = {0};\n\n        int majorNota = -1;\n        int notaMax = 0;\n\n        for(int i=0; i &lt; n; i++)\n        {\n            int nota;\n            scanf(\"%d\", &amp;nota);\n            notas[nota]++;\n        }   \n\n        for(int i=0; i &lt;= 100; i++)\n        {\n            if(notas[i] &gt;= notaMax)\n            {\n                notaMax = notas[i];\n                majorNota = i;\n            }\n        } \n        printf(\"%d\\n\", majorNota);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/02_hashing/#hash-it","title":"Hash it!","text":"F-hashit.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n\n    int add(char my_map[][101], char* key){\n        int h, hash, new_hash;\n        h = 0;\n        for(int i=0; i&lt;strlen(key); i++){\n            h += (int)key[i]*(i+1);\n        }\n        hash = (h*19)%101;\n\n        if(strcmp(my_map[hash], key) == 0){\n            return 0;\n        }\n\n        else{\n            for(int j=1; j&lt;=19; j++){\n                new_hash = (hash+(23*j)+(j*j))%101;\n                if(strcmp(my_map[new_hash], key) == 0){\n                    return 0;\n                }\n            }\n        }\n\n        if(strcmp(my_map[hash], \"\") == 0){\n            strcpy(my_map[hash], key);\n            return 1;\n        }\n        for(int j=1; j&lt;=19; j++){\n            new_hash = (hash+(j*j)+(23*j))%101;\n\n            if(strcmp(my_map[new_hash], \"\") == 0){\n                strcpy(my_map[new_hash], key);\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    int del(char my_map[][101], char* key){\n        for(int i=0; i&lt;101; i++){\n\n            if(strcmp(my_map[i], key) == 0){\n                strcpy(my_map[i], \"\");\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    int main(){\n        int N, m, number_of_entries;\n        char op[101], key[101];\n        char my_map[101][101];\n        scanf(\"%d\", &amp;N);\n        for(int testcase=0; testcase&lt;N; testcase++){\n            scanf(\"%d\", &amp;m);\n\n            number_of_entries = 0;\n\n            for(int i=0; i&lt;101; i++){\n                strcpy(my_map[i], \"\");\n            }\n            for(int operation=0; operation&lt;m; operation++){\n                scanf(\"%s\", op);\n\n                if(strncmp(op, \"ADD\", 3) == 0){\n                    strcpy(key, op+4);\n                    if(add(my_map, key)){\n                        number_of_entries++;\n                    }\n                }\n                else if(strncmp(op, \"DEL\", 3) == 0){\n                    strcpy(key, op+4);\n                    if(del(my_map, key)){\n                        number_of_entries--;\n                    }\n                }\n            }\n            printf(\"%d\\n\", number_of_entries);\n            for(int i=0; i&lt;101; i++){\n                if(strcmp(my_map[i], \"\") != 0){\n                    printf(\"%d:%s\\n\", i, my_map[i]);\n                }\n            }\n            printf(\"\\n\");\n        }\n        return 0;\n    }\n</code></pre>"},{"location":"exec/02_hashing/#hash","title":"Hash","text":"<p>N\u00e3o resolvida \ud83d\ude1e</p>"},{"location":"exec/02_hashing/#mensagens-nlogniences","title":"Mensagens Nlogniences","text":"<p>N\u00e3o resolvida \ud83d\ude1e</p>"},{"location":"exec/03_priority_queue/","title":"Lista III - Priority Queue","text":""},{"location":"exec/03_priority_queue/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Aqui se encontram as solu\u00e7\u00f5es dos problemas referentes \u00e0 2\u00aa lista de exerc\u00edcios, focada na estrutura de dados priority queue, e os PDFs de cada problema associados ao t\u00edtulo.</p>"},{"location":"exec/03_priority_queue/#problemas","title":"Problemas","text":""},{"location":"exec/03_priority_queue/#menores-placas","title":"Menores placas","text":"A-menoresPlacas.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct Placas{\n        int *placas;\n        int tam;\n    }Placas;\n\n    void swap(int *a, int *b){\n        int temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n\n    void fixup(int *placas, int i){\n        while(i &gt; 1 &amp;&amp; placas[i / 2] &gt; placas[i]){\n            swap(&amp;placas[i], &amp;placas[i/2]);\n            i /= 2;\n        }\n    }\n\n    void fixdown(int *placas, int tam, int i){\n        while(i * 2 &lt;= tam){\n            int menor = i * 2;\n            if(menor &lt; tam &amp;&amp; placas[menor] &gt; placas[menor + 1]){\n                menor++;\n            }\n            if(placas[i] &lt;= placas[menor]){\n                break;\n            }\n\n            swap(&amp;placas[i], &amp;placas[menor]);\n            i = menor;\n        }\n    }\n\n    void PQinsert(Placas *placas, int p){\n        placas-&gt;placas[++placas-&gt;tam] = p;\n        fixup(placas-&gt;placas, placas-&gt;tam);\n    }\n\n    int PQremove(Placas *placas){\n        if(placas-&gt;tam == 0)\n            return -1;\n\n        int topo = placas-&gt;placas[1];\n        placas-&gt;placas[1] = placas-&gt;placas[placas-&gt;tam--];\n        fixdown(placas-&gt;placas, placas-&gt;tam, 1);\n\n        return topo;\n    }\n\n    int main(){\n\n        Placas placas;\n        placas.tam = 0;\n        placas.placas = (int*)malloc(sizeof(int) * 2000000);\n\n        int op, p, v[100];\n\n        while(scanf(\"%d %d\", &amp;op, &amp;p) != EOF){\n            if(op == 1){\n                PQinsert(&amp;placas, p);\n            }\n            else{\n                int n;\n                for(n = 0; n &lt; p; n++){\n                    int menor = PQremove(&amp;placas);\n                    if(menor == -1){\n                        break;\n                    }\n                    v[n] = menor;\n                }\n                for(int i = 0; i &lt; n; i++){\n                    printf(\"%d \", v[i]);\n                    PQinsert(&amp;placas, v[i]);\n                }\n                printf(\"\\n\");\n            }\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/03_priority_queue/#churrascarias-da-avenida","title":"Churrascarias da Avenida","text":"B-churras.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n\n    #define nota(a) (a-&gt;nota)\n    #define greater(a, b) (nota(a) &gt; nota(b))\n    #define swap(a, b)  \\\n        {               \\\n            Churras t = a; \\\n            a = b;      \\\n            b = t;      \\\n        }\n\n    typedef struct Churras{\n        int nota;\n        int index;\n    }*Churras;\n\n    typedef struct Heap{\n        Churras *heap;\n        int size;\n    } Heap;\n\n    void fixup(Churras *heap, int size){\n\n        for(int i = size; i &gt; 1 &amp;&amp; greater(heap[i/2], heap[i]); i /= 2){\n            swap(heap[i], heap[i/2]);\n            heap[i]-&gt;index = i;\n            heap[i/2]-&gt;index = i/2;\n        }\n    }\n\n    void fixdown(Churras *heap, int size, int i){\n\n        for(int l = i * 2; i * 2 &lt;= size; i = l, l = i * 2){\n\n            if(l &lt; size &amp;&amp; greater(heap[l], heap[l + 1])) l++;\n\n            if(!greater(heap[i], heap[l])) break;\n\n            swap(heap[i], heap[l]);\n            heap[i]-&gt;index = i;\n            heap[l]-&gt;index = l;\n        }\n    }\n\n    Heap PQinit(int k)\n    {\n        Heap hp;\n        hp.size = 0;\n        hp.heap = malloc(sizeof(Churras) * (k + 1));\n        return hp;\n    }\n\n    void PQinsert(Heap *hp, Churras c){\n\n        hp-&gt;heap[++hp-&gt;size] = c;\n        c-&gt;index = hp-&gt;size;\n        fixup(hp-&gt;heap, hp-&gt;size);\n    }\n\n    Churras PQespia(Heap hp){\n        return hp.heap[1];\n    }\n\n    Churras PQremove(Heap *hp, int i){\n        Churras r = hp-&gt;heap[i];\n        hp-&gt;heap[i] = hp-&gt;heap[hp-&gt;size--];\n        fixdown(hp-&gt;heap, hp-&gt;size, i);\n        return r;\n    }\n\n    int main(){\n\n        int n, k;\n        while (scanf(\"%d %d\", &amp;n, &amp;k) == 2){\n\n            if(n == 0 &amp;&amp; k == 0) break;\n\n            Churras c = malloc(n * sizeof(struct Churras));\n\n            for(int i = 0; i &lt; n; i++)\n                scanf(\"%d\", &amp;c[i].nota);     \n\n            Heap hp = PQinit(k); \n\n            for(int i = 0; i &lt; k - 1; i++)\n                PQinsert(&amp;hp, &amp;c[i]);\n\n            for(int i = k - 1; i &lt; n; i++){\n                PQinsert(&amp;hp, &amp;c[i]);\n                printf(\"%d%c\", PQespia(hp)-&gt;nota, \" \\n\"[i == n - 1]);\n                PQremove(&amp;hp, c[i - k + 1].index);\n            }\n            free(hp.heap);\n        }    \n        return 0;\n    }\n</code></pre>"},{"location":"exec/03_priority_queue/#minimun-stocks","title":"Minimun Stocks","text":"C-minStocks.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n    #include &lt;string.h&gt;\n\n    #define price(a) (a.price)\n    #define less(a, b) (price(a) &lt; price(b))\n    #define swap(a, b)\\\n        {             \\\n            Stock t = a;\\\n            a = b;    \\\n            b = t;    \\\n        }             \n\n    typedef struct Stock{\n        char name[11];\n        int price;\n    }Stock;\n\n    typedef struct Heap{\n        Stock *data;\n        int size;\n    }Heap;\n\n    Heap* PQinit(int n){\n        Heap *hp = malloc(sizeof(Heap));\n        hp-&gt;size = 0;\n        hp-&gt;data = malloc(sizeof(Stock) * (n + 1));\n        return hp;\n    }   \n\n    void fixup(Heap *hp, int i){\n        int p = (i - 1) / 2;\n        while(i &gt; 0 &amp;&amp; hp-&gt;data[i].price &lt; hp-&gt;data[p].price){\n            swap(hp-&gt;data[i], hp-&gt;data[p]);\n            i = p;\n            p = (i - 1) / 2;\n        }\n    }\n\n\n    void fixdown(Heap *hp, int i){\n        int small = i;\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n\n        if(left &lt; hp-&gt;size &amp;&amp; hp-&gt;data[left].price &lt; hp-&gt;data[small].price)\n            small = left;\n        if(right &lt; hp-&gt;size &amp;&amp; hp-&gt;data[right].price &lt; hp-&gt;data[small].price)\n            small = right;\n\n        if(small != i){\n            swap(hp-&gt;data[i], hp-&gt;data[small]);\n            fixdown(hp, small);\n        }\n    }\n\n    void PQinsert(Heap *hp, Stock stock){\n        hp-&gt;data[hp-&gt;size] = stock;\n        fixup(hp, hp-&gt;size);\n        hp-&gt;size++;\n    }\n\n    void PQatualiza(Heap *hp, char *name, int newprice){\n        for(int i = 0; i &lt; hp-&gt;size; i++){\n            if(strcmp(hp-&gt;data[i].name, name) == 0){\n                hp-&gt;data[i].price = newprice;\n                fixup(hp, i);\n                fixdown(hp, i);\n                break;\n            }\n        }\n    }\n\n    Stock PQremove(Heap *hp){\n        if(hp-&gt;size == 0){\n            Stock empty = {\"\", 0};\n            return empty;\n        }\n        Stock minStock = hp-&gt;data[0];\n        hp-&gt;size--;\n\n        if(hp-&gt;size &gt; 0){\n            hp-&gt;data[0] = hp-&gt;data[hp-&gt;size];\n            fixdown(hp, 0);\n        }\n\n        return minStock;\n    }\n\n    int main(){\n\n        int inst, n;\n        scanf(\"%d\", &amp;n);\n\n        Heap *hp = PQinit(n);\n\n        for(int i = 1; i &lt;= n; i++){\n\n            Stock stock;\n\n            scanf(\"%d\", &amp;inst);\n            if(inst == 1){\n                scanf(\"%s %d\", stock.name, &amp;stock.price);\n                PQinsert(hp, stock); \n\n            }else if (inst == 2){\n                scanf(\"%s %d\", stock.name, &amp;stock.price);\n                PQatualiza(hp, stock.name, stock.price);\n\n            }else{\n                char buy[3];\n                scanf(\"%s\", buy);\n                Stock r = PQremove(hp);\n                if(r.price &gt; 0)\n                    printf(\"%s %d\\n\", r.name, i);\n            }\n        }\n        free(hp-&gt;data);\n        free(hp);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/04_quickselect/","title":"Lista IV - Quick Select","text":""},{"location":"exec/04_quickselect/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Aqui se encontram as solu\u00e7\u00f5es dos problemas referentes \u00e0 2\u00aa lista de exerc\u00edcios, focada no algoritmo quickselect, e os PDFs de cada problema associados ao t\u00edtulo.</p>"},{"location":"exec/04_quickselect/#problemas","title":"Problemas","text":""},{"location":"exec/04_quickselect/#classificados-de-sementes","title":"Classificados de sementes","text":"A-classificadoDeSementes.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n    #include &lt;string.h&gt;\n\n    #define lessNota(a ,b) (a.nota == b.nota ? a.cod &lt; b.cod : a.nota &lt; b.nota)\n    #define lessCod(a, b) (a.cod == b.cod ? a.nota &lt; b.nota : a.cod &lt; b.cod)\n    #define swap(a, b)\\\n        {             \\\n            Semente temp = a; \\\n            a = b;    \\\n            b = temp; \\\n        }\n\n    #define cmpswapNota(a, b)\\\n       if(lessNota(b, a))    \\\n            swap(a, b)       \n\n    #define cmpswapCod(a, b)\\\n        if(lessCod(b, a))   \\\n            swap(a, b)      \n\n    typedef struct Semente{\n        long long cod;\n        int nota;\n    }Semente;\n\n    int separaCod(Semente *v, int l, int r)\n    {\n        Semente pivo = v[r];\n        int j = l;\n\n        for(int i = l; i &lt; r; i++)\n            if(lessCod(v[i], pivo))\n            {\n                swap(v[i], v[j]);\n                j++;\n            }\n\n        swap(v[j], v[r]);\n        return j;\n    }\n\n    void quicksortM3(Semente *v, int l, int r)\n    {\n        if(r - l &lt;= 32) return;\n\n        int mid = (l + r) / 2;\n\n        swap(v[mid], v[r - 1]);\n        cmpswapCod(v[l], v[r - 1]);\n        cmpswapCod(v[l], v[r]);\n        cmpswapCod(v[r - 1], v[r]);\n\n        int m = separaCod(v, l, r);\n        quicksortM3(v, l, m - 1);\n        quicksortM3(v, m + 1, r);\n    }\n\n    void insertionSort(Semente *v, int l, int r)\n    {\n        int j;\n        for(int i = l + 1; i &lt;= r; i++)\n        {\n            Semente s = v[i];\n            for(j = i; j &gt; 0 &amp;&amp; lessCod(s, v[j - 1]); j--)\n                v[j] = v[j - 1];\n            v[j] = s;\n        }\n    }\n\n    void quicksort(Semente *v, int l, int r)\n    {\n        quicksortM3(v, l, r);\n        insertionSort(v, l, r);\n    }\n\n    int separaNota(Semente *v, int l, int r)\n    {\n        Semente pivo = v[r];\n        int j = l;\n\n        for(int i = l; i &lt; r; i++)\n            if(lessNota(v[i], pivo))\n            {\n                swap(v[i], v[j]);\n                j++;\n            }\n\n        swap(v[j], v[r]);\n        return j;\n    }\n\n    void quickselect(Semente *v, int l, int r, int k)\n    {\n        int mid = (l + r) / 2;\n        cmpswapNota(v[mid], v[r]);\n        cmpswapNota(v[l], v[mid]);\n        cmpswapNota(v[r], v[mid]);\n\n        int m = separaNota(v, l, r);\n        if(m &gt; k)\n            quickselect(v, l, m - 1, k);\n        else if(m &lt; k)\n            quickselect(v, m + 1, r, k);\n    }\n\n    Semente v[10000001];\n\n    int main(){\n\n        int n;\n        scanf(\" %d\",&amp;n);\n        int i;\n        for(i = 0; scanf(\"%lld %d\", &amp;v[i].cod, &amp;v[i].nota) == 2; i++);\n\n        quickselect(v, 0, i - 1, n - 1);\n        quicksort(v, 0, n - 1);\n\n        for(int j=0; j &lt; n; j++)\n            printf(\"%lld %d\\n\", v[j].cod, v[j].nota);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/04_quickselect/#kk-pagina","title":"kk-p\u00e1gina","text":"B-kk-pagina.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    #define less(a, b) (a &lt; b)\n    #define min(a, b) (a &lt; b ? a : b)\n    #define swap(a, b)    \\\n        {                 \\\n            int temp = a; \\\n            a = b;        \\\n            b = temp;     \\\n        }\n    #define cmpswap(a, b) \\\n        if (less(b, a))   \\\n        swap(a, b)\n\n    int separa(int *v, int l, int r)\n    {\n        int pivo = v[r];\n        int j = l;\n        for (int i = l; i &lt; r; i++)\n            if (less(v[i], pivo))\n            {\n                swap(v[i], v[j])\n                    j++;\n            }\n        swap(v[j], v[r]);\n        return j;\n    }\n\n    void quicksortM3(int *v, int l, int r)\n    {\n        if (r - l &lt;= 32)\n            return;\n\n        int mid = (l + r) / 2;\n\n        swap(v[mid], v[r - 1]);\n        cmpswap(v[l], v[r - 1]);\n        cmpswap(v[l], v[r]);\n        cmpswap(v[r - 1], v[r]);\n\n        int m = separa(v, l, r);\n        quicksortM3(v, l, m - 1);\n        quicksortM3(v, m + 1, r);\n    }\n\n    void insertionsort(int *v, int l, int r)\n    {\n        int j;\n        for (int i = l + 1; i &lt;= r; i++)\n        {\n            int temp = v[i];\n            for (j = i; j &gt; 0 &amp;&amp; less(temp, v[j - 1]); j--)\n                v[j] = v[j - 1];\n            v[j] = temp;\n        }\n    }\n\n    void quicksort(int *v, int l, int r)\n    {\n        quicksortM3(v, l, r);\n        insertionsort(v, l, r);\n    }\n\n    void quickselect(int *v, int l, int r, int k)\n    {\n        if (k &lt; l || k &gt; r)\n            return;\n\n        int mid = (l + r) / 2;\n        cmpswap(v[mid], v[r]);\n        cmpswap(v[l], v[mid]);\n        cmpswap(v[r], v[mid]);\n\n        int m = separa(v, l, r);\n        if (m &gt; k)\n            quickselect(v, l, m - 1, k);\n        else if (m &lt; k)\n            quickselect(v, m + 1, r, k);\n    }\n\n    int main()\n    {\n        int n, p, x;\n        scanf(\" %d %d %d\", &amp;n, &amp;p, &amp;x);\n\n        int *paginas = (int *)malloc(n * sizeof(int));\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            scanf(\" %d\", &amp;paginas[i]);\n        }\n\n        int ini = p * x;\n        int fim = ini + x;\n\n        quickselect(paginas, 0, n - 1, min(n - 1, ini));\n        quickselect(paginas, 0, n - 1, min(n - 1, (p + 1) * x - 1));\n        quicksort(paginas, min(n - 1, ini), min(n - 1, (p + 1) * x - 1));\n\n        for (int i = ini; i &lt; min(n, (p + 1) * x); i++)\n        {\n            printf(\"%d\\n\", paginas[i]);\n        }\n\n        free(paginas);\n        return 0;\n    }\n</code></pre>"},{"location":"exec/04_quickselect/#desfile-dos-patos","title":"Desfile dos patos","text":"C-desfileDosPatos.c<pre><code>    #include &lt;stdio.h&gt;\n\n    #define less(a, b) (a &lt; b)\n    #define swap(a, b)    \\\n        {                    \\\n            int temp = v[a]; \\\n            v[a] = v[b];     \\\n            v[b] = temp;     \\\n        }\n\n    int quickselect(int *v, int l, int r)\n    {\n        int n = r - l + 1;\n        int k = n / 2; // O \u00edndice do elemento do meio (ou seja, o poss\u00edvel majorit\u00e1rio)\n\n        while (1)\n        {\n            int i = l;\n            int j = r;\n            int pivo = v[l];\n\n            while (i &lt; j)\n            {\n                while (v[i] &lt; pivo)\n                    i++;\n\n                while (v[j] &gt; pivo)\n                    j--;\n\n                if (i &lt;= j)\n                {\n                    swap(i, j);\n                    i++;\n                    j--;\n                }\n            }\n\n            if (j &lt; k)\n                l = i;\n            if (k &lt; i)\n                r = j;\n            if (i &lt;= k &amp;&amp; k &lt;= j)\n                return v[k];\n        }\n    }\n    int main(){\n        int n;\n\n        while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n != 0){\n\n            int colors[1000001] = {0};\n            int colorMax = -1;\n\n            for(int i = 0; i&lt;n; i++)\n                scanf(\"%d\", &amp;colors[i]);\n\n            colorMax = quickselect(colors, 0, n - 1);\n            printf(\"%d\\n\", colorMax);\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/04_quickselect/#menores-placas","title":"Menores placas","text":"D-menoresPlacas.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct Placas{\n        int *placas;\n        int tam;\n    }Placas;\n\n    void swap(int *a, int *b){\n        int temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n\n    void fixup(int *placas, int i){\n        while(i &gt; 1 &amp;&amp; placas[i / 2] &gt; placas[i]){\n            swap(&amp;placas[i], &amp;placas[i/2]);\n            i /= 2;\n        }\n    }\n\n    void fixdown(int *placas, int tam, int i){\n        while(i * 2 &lt;= tam){\n            int menor = i * 2;\n            if(menor &lt; tam &amp;&amp; placas[menor] &gt; placas[menor + 1]){\n                menor++;\n            }\n            if(placas[i] &lt;= placas[menor]){\n                break;\n            }\n\n            swap(&amp;placas[i], &amp;placas[menor]);\n            i = menor;\n        }\n    }\n\n    void PQinsert(Placas *placas, int p){\n        placas-&gt;placas[++placas-&gt;tam] = p;\n        fixup(placas-&gt;placas, placas-&gt;tam);\n    }\n\n    int PQremove(Placas *placas){\n        if(placas-&gt;tam == 0)\n            return -1;\n\n        int topo = placas-&gt;placas[1];\n        placas-&gt;placas[1] = placas-&gt;placas[placas-&gt;tam--];\n        fixdown(placas-&gt;placas, placas-&gt;tam, 1);\n\n        return topo;\n    }\n\n    int main(){\n\n        Placas placas;\n        placas.tam = 0;\n        placas.placas = (int*)malloc(sizeof(int) * 2000000);\n\n        int op, p, v[100];\n\n        while(scanf(\"%d %d\", &amp;op, &amp;p) != EOF){\n            if(op == 1){\n                PQinsert(&amp;placas, p);\n            }\n            else{\n                int n;\n                for(n = 0; n &lt; p; n++){\n                    int menor = PQremove(&amp;placas);\n                    if(menor == -1){\n                        break;\n                    }\n                    v[n] = menor;\n                }\n                for(int i = 0; i &lt; n; i++){\n                    printf(\"%d \", v[i]);\n                    PQinsert(&amp;placas, v[i]);\n                }\n                printf(\"\\n\");\n            }\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/05_grafos/","title":"Lista V - Grafos","text":""},{"location":"exec/05_grafos/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Aqui se encontram as solu\u00e7\u00f5es dos problemas referentes \u00e0 2\u00aa lista de exerc\u00edcios, focada na estrutura de dados grafos, e os PDFs de cada problema associados ao t\u00edtulo.</p>"},{"location":"exec/05_grafos/#problemas","title":"Problemas","text":""},{"location":"exec/05_grafos/#eu-vou-estar-la","title":"Eu vou estar l\u00e1!","text":"A-euVouEstarLa.c<pre><code>    #include &lt;stdio.h&gt;\n\n    int g[2001][2001];          //matriz de adjac\u00eancias\n    int v[2001] = {0};  \n\n    int main()\n    {\n        int n, m, j;\n        scanf(\" %d %d %d\", &amp;n, &amp;m, &amp;j);\n\n\n        for (int i = 0; i &lt; n; i++){\n            g[i][i] = 1;            //seta a diagonal principal (conex\u00e3o do elemento com ele mesmo)\n\n            int x, y;\n            scanf(\" %d\", &amp;x);       //N\u00famero de conex\u00f5es de i\n\n            while(x--){\n                scanf(\" %d\", &amp;y);   //Conex\u00f5es de i\n                g[i][y] = 1;        //seta conex\u00f5es de i com y\n            }\n        }\n\n        for (int i = 0; i &lt; m; i++){\n            int x;\n            scanf(\" %d\", &amp;x);\n\n            for(int k = 0; k &lt; n; k++){\n                if( g[x][k] == 1)\n                    v[k] = 1;\n            }\n        }\n\n        while(j--){\n            int x;\n            scanf(\" %d\", &amp;x);\n            if(v[x] == 1){\n                printf(\"Eu vou estar la\\n\");\n            }else{\n                printf(\"Nao vou estar la\\n\");\n            }\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/05_grafos/#estradas-asfaltadas-o-inicio","title":"Estradas asfaltadas - o in\u00edcio","text":"B-estradasAsfaltadas.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n    #include &lt;stdbool.h&gt;\n\n    typedef struct Edge{\n        int v, w;\n    }Edge;\n\n    typedef struct Graph{\n        int numVertex;\n        Edge **edges;\n    }Graph;\n\n    #define NULL_EDGE ((Edge){-1, -1});\n\n    Graph GraphInit(int v){\n        Graph g;\n        g.numVertex = v;\n        g.edges = malloc(sizeof(Edge *) * v);\n        for(int i = 0; i &lt; v; i++){\n            g.edges[i] = malloc(sizeof(Edge) * v);\n            for(int j = 0; j &lt; v; j++)\n                g.edges[i][j] = NULL_EDGE;    \n        }\n        return g;\n    }\n\n    void GraphFree(Graph g){\n        for(int i = 0; i &lt; g.numVertex; i++)\n            free(g.edges[i]);\n        free(g.edges);\n    }\n\n    void GraphInsert(Graph *g, Edge e){\n        if(e.v &gt; g-&gt;numVertex || e.w &gt; g-&gt;numVertex)\n            return; \n\n        g-&gt;edges[e.v][e.w] = e;\n    }\n\n    void dfs(Graph g, int start, bool visited[]){\n        visited[start] = true;\n        for(int i = 0; i &lt; g.numVertex; i++){\n            Edge e = g.edges[start][i];\n            if(e.v != -1 &amp;&amp; !visited[i])\n                dfs(g, i, visited);\n        }\n    }\n\n\n    bool visited[5001];\n\n    int main(){\n        int V;\n        scanf(\" %d\", &amp;V);\n\n        Graph g = GraphInit(V);\n\n\n        for(int v ,w; scanf(\" %d %d\", &amp;v, &amp;w) == 2;){   \n            GraphInsert(&amp;g, (Edge){.v = v, .w = w});\n            GraphInsert(&amp;g, (Edge){.v = w, .w = v});\n        }\n\n        int cont = 0;\n        for(int i = 0; i &lt; V; i++){\n            if(!visited[i]){\n                dfs(g, i, visited);\n                cont++;\n            }\n        }\n\n        printf(\"%d\\n\", cont);\n        GraphFree(g);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/05_grafos/#estradas-asfaltadas-viagem-aerea","title":"Estradas asfaltadas - viagem a\u00e9rea","text":"C-estradasAsfaltadasViagemAerea.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct Edge{\n        int v, w;\n    }Edge;\n\n    typedef struct Graph{\n        int numVertex, numEdges;\n        Edge **edges;\n    }Graph;\n\n    #define NULL_EDGE ((Edge){-1, -1});\n\n    Graph GraphInit(int v){\n        Graph g;\n        g.numVertex = v;\n        g.numEdges = 0;\n        g.edges = malloc(sizeof(Edge *) * v);\n        for(int i = 0; i &lt; v; i++){\n            g.edges[i] = malloc(sizeof(Edge) * v);\n            for(int j = 0; j &lt; g.numVertex; j++)\n                g.edges[i][j] = NULL_EDGE;    \n        }\n        return g;\n    }\n\n    void GraphFree(Graph g){\n        for(int i = 0; i &lt; g.numVertex; i++)\n            free(g.edges[i]);\n        free(g.edges);\n    }\n\n    void GraphInsert(Graph *g, Edge e){\n        if(e.v &gt; g-&gt;numVertex || e.w &gt; g-&gt;numVertex)\n            return; \n\n        g-&gt;edges[e.v][e.w] = e;\n        g-&gt;numEdges++;\n    }\n\n    void GraphConnections(Graph g, int start ,int components[]){\n        if (components[start] &lt; 0)\n            components[start] = start;\n\n        for(int i = 0; i &lt; g.numVertex; i++){\n            Edge e = g.edges[start][i];\n            if(e.v != -1 &amp;&amp; components[i] &lt; 0){\n                int min = ((int)i &lt; components[start] ? (int)i : components[start]);\n                components[start] = min;\n                components[i] = min;\n                GraphConnections(g, i, components);\n            }\n        }\n    }\n\n    int components[5001];\n\n    int main(){\n        int V, J;\n        scanf(\" %d %d\", &amp;V, &amp;J);\n\n        Graph g = GraphInit(V);\n\n        for(int v ,w; scanf(\" %d %d\", &amp;v, &amp;w) == 2;){   \n            GraphInsert(&amp;g, (Edge){.v = v, .w = w});\n            GraphInsert(&amp;g, (Edge){.v = w, .w = v});\n        }\n\n        for(int i = 0; i &lt; V; i++)\n            components[i] = -1;\n\n        for(int i = 0; i &lt; V; i++)\n            GraphConnections(g, i, components);  \n\n        GraphFree(g);\n\n        int *max = malloc(sizeof(int) * V);\n        for(int i = 0; i &lt; V; i++)\n            max[i] = 0;\n\n        int cont = V - 1;\n        for(int i = V - 1; i &gt;= 0; i--)\n        {\n            if(++max[components[i]] &gt; max[cont] || (max[components[i]] == max[cont] &amp;&amp; cont != components[J] &amp;&amp; components[i] &lt; cont))\n                cont = components[i];\n        }\n\n        free(max);\n\n        if(cont == components[J] &amp;&amp; g.numEdges == 0)\n            printf(\"Fique em casa\\n\");\n        else if(cont == components[J])\n            printf(\"Bora pra estrada\\n\");\n       else\n            printf(\"Vamos para %d\\n\", cont);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/05_grafos/#natureza","title":"Natureza","text":"D-natureza.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct Edge\n    {\n        int v, w;\n    } Edge;\n\n    typedef struct Graph\n    {\n        int numVertex, numEdges;\n        Edge **edges;\n    } Graph;\n\n    #define NULL_EDGE ((Edge){-1, -1});\n\n    Graph GraphInit(int v)\n    {\n        Graph g;\n        g.numVertex = v;\n        g.numEdges = 0;\n        g.edges = malloc(sizeof(Edge *) * v);\n        for (int i = 0; i &lt; v; i++)\n        {\n            g.edges[i] = malloc(sizeof(Edge) * v);\n            for (int j = 0; j &lt; g.numVertex; j++)\n                g.edges[i][j] = NULL_EDGE;\n        }\n        return g;\n    }\n\n    void GraphFree(Graph g)\n    {\n        for (int i = 0; i &lt; g.numVertex; i++)\n            free(g.edges[i]);\n        free(g.edges);\n    }\n\n    void GraphInsert(Graph *g, Edge e)\n    {\n        if (e.v &gt; g-&gt;numVertex || e.w &gt; g-&gt;numVertex)\n            return;\n\n        g-&gt;edges[e.v][e.w] = e;\n        g-&gt;numEdges++;\n    }\n\n    void GraphConnections(Graph g, int start, int connections[])\n    {\n        if (connections[start] &lt; 0)\n            connections[start] = start;\n\n        for (int i = 0; i &lt; g.numVertex; i++)\n        {\n            Edge e = g.edges[start][i];\n            if (e.v != -1 &amp;&amp; connections[i] &lt; 0)\n            {\n                int min = ((int)i &lt; connections[start] ? (int)i : connections[start]);\n                connections[start] = min;\n                connections[i] = min;\n                GraphConnections(g, i, connections);\n            }\n        }\n    }\n\n    int connections[5001], freq[5001];\n    char animals[5001][32];\n\n    int main()\n    {\n\n        while (1)\n        {\n            int v, c;\n            scanf(\" %d %d\", &amp;v, &amp;c);\n            if (!v &amp;&amp; !c)\n                break;\n\n            for (int i = 0; i &lt; v; i++)\n                connections[i] = -1, freq[i] = 0;\n\n            for (int i = 0; i &lt; v; i++)\n                scanf(\" %s\", animals[i]);\n\n            Graph g = GraphInit(v);\n\n            for (int i = 0; i &lt; c; i++)\n            {\n                char a[32], b[32];\n                scanf(\" %s %s\", a, b);\n                int ai = -1, bi = -1;\n                for (int j = 0; j &lt; v &amp;&amp; (ai == -1 || bi == -1); j++)\n                {\n                    if (ai == -1 &amp;&amp; strcmp(animals[j], a) == 0)\n                        ai = j;\n                    else if (bi == -1 &amp;&amp; strcmp(animals[j], b) == 0)\n                        bi = j;\n                }\n                GraphInsert(&amp;g, (Edge){.v = bi, .w = ai});\n                GraphInsert(&amp;g, (Edge){.v = ai, .w = bi});\n            }\n\n            for (int i = 0; i &lt; v; i++)\n                GraphConnections(g, i, connections);\n            GraphFree(g);\n\n            int ans = 0;\n            for (int i = 0; i &lt; v; i++)\n                if (++freq[connections[i]] &gt; ans)\n                    ans = freq[connections[i]];\n\n            printf(\"%d\\n\", ans);\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/05_grafos/#ir-e-vir","title":"Ir e vir","text":"E-irEVir.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;string.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    #define NULL_EDGE -1\n\n    typedef struct Edge\n    {\n        int v, w;\n    } Edge;\n\n    typedef struct Graph\n    {\n        int numVertex, numEdges;\n        int **edges;\n    } Graph;\n\n    Graph GraphInit(int v)\n    {\n        Graph g = {.numVertex = v, .numEdges = 0};\n        g.edges = malloc(sizeof(int *) * g.numVertex);\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n        {\n            g.edges[i] = malloc(sizeof(int) * g.numVertex);\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n                g.edges[i][j] = NULL_EDGE;\n        }\n        return g;\n    }\n\n    void GraphFree(Graph g)\n    {\n        for (int i = 0; i &lt; g.numVertex; i++)\n            free(g.edges[i]);\n        free(g.edges);\n    }\n\n    void GraphInsert(Graph *g, Edge e)\n    {\n        if (e.v &gt; g-&gt;numVertex || e.w &gt; g-&gt;numVertex)\n            return;\n\n        g-&gt;numEdges += (g-&gt;edges[e.v][e.w] == NULL_EDGE);\n        g-&gt;edges[e.v][e.w] = 1;\n    }\n\n    void FloydWarshall(Graph g, int transitive[][2001])\n    {\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n        {\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n                transitive[i][j] = g.edges[i][j] != NULL_EDGE;\n            transitive[i][i] = 1;\n        }\n\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n                if (transitive[j][i] == 1)\n                    for (unsigned k = 0; k &lt; g.numVertex; k++)\n                        if (transitive[i][k] == 1)\n                            transitive[j][k] = 1;\n    }\n\n    int t[2001][2001];\n\n    int main()\n    {\n        int n, m;\n        while (scanf(\" %d\", &amp;n))\n        {\n            if (!n)\n                break;\n\n            scanf(\" %d\", &amp;m);\n            Graph g = GraphInit(n);\n            for (int i = 0, v, w, p; i &lt; m; i++)\n            {\n                scanf(\" %d %d %d\", &amp;v, &amp;w, &amp;p);\n                v--, w--;\n                GraphInsert(&amp;g, (Edge){.v = v, .w = w});\n                if (p == 2)\n                    GraphInsert(&amp;g, (Edge){.v = w, .w = v});\n            }\n\n            for (int i = 0; i &lt; n; i++)\n                for (int j = 0; j &lt; n; j++)\n                    t[i][j] = 0;\n\n            FloydWarshall(g, t);\n            GraphFree(g);\n\n            int cont = 1;\n            for (int i = 0; i &lt; n &amp;&amp; cont; i++)\n                for (int j = 0; j &lt; n &amp;&amp; cont; j++)\n                    if (!t[i][j])\n                        cont = 0;\n\n            printf(\"%d\\n\", cont);\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/06_busca_em_grafos/","title":"Lista VI - Busca em Grafos","text":""},{"location":"exec/06_busca_em_grafos/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Aqui se encontram as solu\u00e7\u00f5es dos problemas referentes \u00e0 2\u00aa lista de exerc\u00edcios, focada nos algoritmos fundamentais de grafos, e os PDFs de cada problema associados ao t\u00edtulo.</p>"},{"location":"exec/06_busca_em_grafos/#problemas","title":"Problemas","text":""},{"location":"exec/06_busca_em_grafos/#estradas-asfaltadas-perguntando-conexoes","title":"Estradas asfaltadas - perguntando conex\u00f5es","text":"A-estradasAsfaltadasPerguntaConexoes.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n    #include &lt;stdbool.h&gt;\n\n    typedef struct Edge\n    {\n        int v, w;\n    } Edge;\n\n    typedef struct Graph\n    {\n        int numVertex, numEdges;\n        int **edges;\n    } Graph;\n\n    #define NULL_EDGE -1\n\n    Graph GraphInit(int numVertex)\n    {\n        Graph g = {.numVertex = numVertex, .numEdges = 0};\n        g.edges = malloc(sizeof(int *) * g.numVertex);\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n        {\n            g.edges[i] = malloc(sizeof(int) * g.numVertex);\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n            {\n                g.edges[i][j] = NULL_EDGE;\n            }\n        }\n        return g;\n    }\n\n    void GraphFree(Graph g)\n    {\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n            free(g.edges[i]);\n        free(g.edges);\n    }\n\n    void GraphInsert(Graph *g, Edge e)\n    {\n        if (e.v &gt; g-&gt;numVertex || e.w &gt; g-&gt;numVertex)\n            return;\n\n        g-&gt;numEdges += (g-&gt;edges[e.v][e.w] == NULL_EDGE);\n        g-&gt;edges[e.v][e.w] = 1;\n    }\n\n    void FloydWarshall(Graph g, int transitive[][2001])\n    {\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n        {\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n                transitive[i][j] = g.edges[i][j] != NULL_EDGE;\n            transitive[i][i] = 1;\n        }\n\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n                if (transitive[j][i] == 1)\n                    for (unsigned k = 0; k &lt; g.numVertex; k++)\n                        if (transitive[i][k] == 1)\n                            transitive[j][k] = 1;\n    }\n\n    int tr[2001][2001];\n\n    int main(void)\n    {\n        int V;\n        scanf(\" %d\", &amp;V);\n\n        Graph g = GraphInit(V);\n\n        int v, w, d;\n        for (; scanf(\" %d %d %d\", &amp;v, &amp;w, &amp;d) == 3 &amp;&amp; d;)\n        {\n            GraphInsert(&amp;g, (Edge){.v = v, .w = w});\n            if(d == 2)\n                GraphInsert(&amp;g, (Edge){.v = w, .w = v});\n        }\n\n        FloydWarshall(g, tr);\n        GraphFree(g);\n\n        for(int t, x; scanf(\" %d %d\", &amp;t, &amp;x) == 2;)\n            printf(\"%s\\n\", (tr[t][x] &amp;&amp; tr[x][t] ? \"Ida e volta\" : (tr[t][x] ? \"Apenas Ida\" : (tr[x][t] ? \"Apenas Volta\" : \"Impossibru\"))));\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/06_busca_em_grafos/#cai-fora-lag","title":"Cai fora LAG","text":"B-CaiForaLag.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct Node\n    {\n        int data;\n        struct Node *next;\n    } Node;\n\n    typedef struct Queue\n    {\n        int size;\n        Node *head;\n        Node *tail;\n    } Queue;\n\n    Queue QueueInit()\n    {\n        return (Queue){.head = NULL, .tail = NULL, .size = 0};\n    }\n\n    int front(Queue *q)\n    {\n        int front;\n        if (q-&gt;size &gt; 0)\n            front = q-&gt;head-&gt;data;\n        return front;\n    }\n\n    int back(Queue *q)\n    {\n        int back;\n        if (q-&gt;size &gt; 0)\n            back = q-&gt;tail-&gt;data;\n        return back;\n    }\n\n    void push(Queue *q, int data)\n    {\n        Node *n = (Node *)malloc(sizeof(Node));\n        n-&gt;data = data;\n        n-&gt;next = NULL;\n\n        if (q-&gt;size == 0)\n        {\n            q-&gt;head = n;\n            q-&gt;tail = n;\n        }\n        else\n        {\n            q-&gt;tail-&gt;next = n;\n            q-&gt;tail = n;\n        }\n        q-&gt;size++;\n    }\n\n    int pop(Queue *q)\n    {\n        int value = front(q);\n\n        if (q-&gt;size &gt; 0)\n        {\n            Node *removed = q-&gt;head;\n            q-&gt;head = q-&gt;head-&gt;next;\n            if (!q-&gt;head)\n            {\n                q-&gt;tail = NULL;\n            }\n            free(removed);\n            q-&gt;size--;\n        }\n        return value;\n    }\n\n    void clear(Queue *q)\n    {\n        while (q-&gt;size &gt; 0)\n            pop(q);\n    }\n\n    typedef struct Edge\n    {\n        int v, w;\n        int weight;\n    } Edge;\n\n    typedef struct Graph\n    {\n        int numVertex, numEdges;\n        int **edges;\n    } Graph;\n\n    #define NULL_EDGE 2147483647\n    #define sum(a, b) (a + b)\n    #define less(a, b) (a &lt; b)\n\n    Graph GraphInit(int numVertex)\n    {\n        Graph g = {.numVertex = numVertex, .numEdges = 0};\n        g.edges = malloc(sizeof(int *) * g.numVertex);\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n        {\n            g.edges[i] = malloc(sizeof(int) * g.numVertex);\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n            {\n                g.edges[i][j] = NULL_EDGE;\n            }\n        }\n        return g;\n    }\n\n    void GraphFree(Graph g)\n    {\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n            free(g.edges[i]);\n        free(g.edges);\n    }\n\n    void GraphInsert(Graph *g, Edge e)\n    {\n        if (e.v &gt; g-&gt;numVertex || e.w &gt; g-&gt;numVertex)\n            return;\n\n        g-&gt;numEdges += (g-&gt;edges[e.v][e.w] == NULL_EDGE);\n        g-&gt;edges[e.v][e.w] = e.weight;\n    }\n\n    void GraphConnections(Graph g, int start, int connections[])\n    {\n        if (connections[start] &lt; 0)\n            connections[start] = start;\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n            if (g.edges[start][i] != NULL_EDGE &amp;&amp; connections[i] &lt; 0)\n            {\n                int mn = ((int)i &lt; connections[start] ? (int)i : connections[start]);\n                connections[start] = mn;\n                connections[i] = mn;\n                GraphConnections(g, i, connections);\n            }\n    }\n\n    void FloydWarshall(Graph g, int transitive[][2001])\n    {\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n        {\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n                transitive[i][j] = g.edges[i][j] != NULL_EDGE;\n            transitive[i][i] = 1;\n        }\n\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n            for (unsigned j = 0; j &lt; g.numVertex; j++)\n                if (transitive[j][i] == 1)\n                    for (unsigned k = 0; k &lt; g.numVertex; k++)\n                        if (transitive[i][k] == 1)\n                            transitive[j][k] = 1;\n    }\n\n    short bellmanford(Graph g, int start, int *dist)\n    {\n        short *onQueue = malloc(sizeof(short) * g.numVertex);\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n            dist[i] = NULL_EDGE, onQueue[i] = 0;\n        dist[start] = 0;\n\n        Queue q = QueueInit();\n        push(&amp;q, start);\n        onQueue[start] = 1;\n\n        const int sentinel = g.numVertex;\n        unsigned k = 0;\n        push(&amp;q, sentinel);\n\n        while (!q.size == 0)\n        {\n            int v = pop(&amp;q);\n            if (v &lt; sentinel)\n            {\n                for (unsigned i = 0; i &lt; g.numVertex; i++)\n                {\n                    if (g.edges[v][i] == NULL_EDGE)\n                        continue;\n\n                    if (less(sum(dist[v], g.edges[v][i]), dist[i]))\n                    {\n                        dist[i] = k == g.numVertex ? NULL_EDGE : sum(dist[v], g.edges[v][i]);\n                        if (!onQueue[i])\n                        {\n                            push(&amp;q, i);\n                            onQueue[i] = 1;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if (q.size == 0)\n                    return 1;\n                if (++k &gt;= g.numVertex + 1)\n                    return 0;\n                push(&amp;q, v);\n                for (unsigned i = 0; i &lt; g.numVertex; i++)\n                    onQueue[i] = 0;\n            }\n        }\n\n        clear(&amp;q);\n        free(onQueue);\n        return 1;\n    }\n\n    int distX[2001][2001], distS[2001][2001], tc[2001][2001], negative_cycles[2001];\n\n    int main()\n    {\n        int v;\n        scanf(\" %d\", &amp;v);\n\n        Graph gX = GraphInit(v), gS = GraphInit(v);\n        for (int f, t, c, d; scanf(\" %d %d %d %d\", &amp;f, &amp;t, &amp;c, &amp;d) == 4 &amp;&amp; (f | t | c | d);)\n        {\n            GraphInsert(&amp;gS, (Edge){.v = f, .w = t, .weight = c});\n            if (d == 0)\n                GraphInsert(&amp;gS, (Edge){.v = t, .w = f, .weight = c});\n\n            if (d == 1)\n                continue;\n\n            GraphInsert(&amp;gX, (Edge){.v = f, .w = t, .weight = c});\n            GraphInsert(&amp;gX, (Edge){.v = t, .w = f, .weight = c});\n        }\n\n        for (int i = 0; i &lt; gS.numVertex; i++)\n        {\n            if (!bellmanford(gS, i, distS[i]))\n                negative_cycles[i] = 1;\n            bellmanford(gX, i, distX[i]);\n        }\n\n        FloydWarshall(gS, tc);\n\n        GraphFree(gX);\n        GraphFree(gS);\n\n        for (int t, x; scanf(\" %d %d\", &amp;t, &amp;x) == 2;)\n        {\n            int ans = distS[t][x] != NULL_EDGE &amp;&amp; distX[t][x] != NULL_EDGE;\n            if (negative_cycles[t])\n            {\n                for (int i = 0; i &lt; v &amp;&amp; ans; i++)\n                    if (distS[t][i] == NULL_EDGE &amp;&amp; (tc[i][t] || tc[i][x]))\n                        ans = 0;\n            }\n\n            if (ans)\n                printf(\"%d %d\\n\", distX[t][x], distS[t][x]);\n            else\n                printf(\"Impossibru\\n\");\n        }\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/06_busca_em_grafos/#caminho-das-pontes","title":"Caminho das pontes","text":"C-CaminhoDasPontes.c<pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    typedef struct Edge\n    {\n        int v, w;\n        int weight;\n    } Edge;\n\n    typedef struct Graph\n    {\n        int numVertex, numEdges;\n        int **edges;\n        int **weights;\n        int *grau;\n    } Graph;\n\n\n    Graph GraphInit(int numVertex)\n    {\n        Graph g = {.numVertex = numVertex, .numEdges = 0};\n        g.grau = calloc(g.numVertex, sizeof(int));\n\n        g.edges = malloc(numVertex * sizeof(int *));\n        for (int i = 0; i &lt; numVertex; i++)\n            g.edges[i] = malloc(numVertex * sizeof(int));\n\n        g.weights = malloc(numVertex * sizeof(int *));\n        for (int i = 0; i &lt; numVertex; i++)\n            g.weights[i] = malloc(numVertex * sizeof(int));\n        return g;\n    }\n\n    void GraphFree(Graph g)\n    {\n        for (unsigned i = 0; i &lt; g.numVertex; i++)\n        {\n\n            free(g.edges[i]);\n            free(g.weights[i]);\n        }\n        free(g.edges);\n        free(g.weights);\n    }\n\n    void GraphInsert(Graph *g, Edge e)\n    {\n        if (e.v &gt; g-&gt;numVertex || e.w &gt; g-&gt;numVertex || e.v &gt;= g-&gt;numVertex || e.w &gt;= g-&gt;numVertex)\n            return;\n\n        g-&gt;edges[e.v][g-&gt;grau[e.v]] = e.w;\n        g-&gt;weights[e.v][g-&gt;grau[e.v]] = e.weight;\n        g-&gt;grau[e.v]++;\n\n        g-&gt;edges[e.w][g-&gt;grau[e.w]] = e.v;\n        g-&gt;weights[e.w][g-&gt;grau[e.w]] = e.weight;\n        g-&gt;grau[e.w]++;\n    }\n\n    int shortPath(int *dist, int *visited, int numVertex)\n    {\n        int smallest = -1, first = 1;\n\n        for (unsigned i = 0; i &lt; numVertex; i++)\n        {\n            if (dist[i] &gt;= 0 &amp;&amp; visited[i] == 0)\n            {\n                if (first)\n                {\n                    smallest = i;\n                    first = 0;\n                }\n                else\n                {\n                    if (dist[smallest] &gt; dist[i])\n                        smallest = i;\n                }\n            }\n        }\n        return smallest;\n    }\n\n    void Dijkstra(Graph *g, int start, int *ant, int *dist, int *visited)\n    {\n        int cont, index, u;\n        cont = g-&gt;numVertex;\n\n        for (unsigned i = 0; i &lt; g-&gt;numVertex; i++)\n        {\n            ant[i] = -1;\n            dist[i] = -1;\n            visited[i] = 0;\n        }\n\n        dist[start] = 0;\n\n        while (cont--)\n        {\n            u = shortPath(dist, visited, g-&gt;numVertex);\n            visited[u] = 1;\n            for (unsigned i = 0; i &lt; g-&gt;grau[u]; i++)\n            {\n                index = g-&gt;edges[u][i];\n                if (dist[index] &lt; 0)\n                    dist[index] = dist[u] + g-&gt;weights[u][i];\n                else if (dist[index] &gt; 0 &amp;&amp; dist[index] &gt; dist[u] + g-&gt;weights[u][i])\n                {\n                    dist[index] = dist[u] + g-&gt;weights[u][i];\n                    ant[index] = u;\n                }\n            }\n        }\n    }\n\n    int main()\n    {\n        int N, M, S, T, B;\n        scanf(\" %d %d\", &amp;N, &amp;M);\n\n        Graph g = GraphInit(N + 2);\n\n        for (unsigned i = 0; i &lt; M; i++)\n        {\n            scanf(\" %d %d %d\", &amp;S, &amp;T, &amp;B);\n            GraphInsert(&amp;g, (Edge){.v = S, .w = T, .weight = B});\n        }\n\n        int *dist = malloc(g.numVertex * sizeof(int));\n        int *ant = malloc(g.numVertex * sizeof(int));\n        int *visited = malloc(g.numVertex * sizeof(int));\n\n        Dijkstra(&amp;g, 0, ant, dist, visited);\n        printf(\"%d\\n\", dist[g.numVertex - 1]);\n\n        GraphFree(g);\n        free(dist);\n        free(ant);\n        free(visited);\n\n        return 0;\n    }\n</code></pre>"},{"location":"exec/06_busca_em_grafos/#o-chao-virou-lava","title":"O ch\u00e3o virou lava","text":"<p>N\u00e3o resolvida \ud83d\ude1e</p>"},{"location":"exec/06_busca_em_grafos/#regra-dos-seis-apertos-de-mao","title":"Regra dos seis apertos de m\u00e3o","text":"<p>N\u00e3o resolvida \ud83d\ude1e</p>"}]}